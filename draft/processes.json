[
  {
    "id": "absolute",
    "summary": "Absolute value",
    "description": "Computes the absolute value of a real number `x`, which is the \"unsigned\" portion of x and often denoted as *|x|*.\n\nThe no-data value `null` is passed through and therefore gets propagated.",
    "categories": [
      "math"
    ],
    "parameters": [
      {
        "name": "x",
        "description": "A number.",
        "schema": {
          "type": [
            "number",
            "null"
          ]
        }
      }
    ],
    "returns": {
      "description": "The computed absolute value.",
      "schema": {
        "type": [
          "number",
          "null"
        ],
        "minimum": 0
      }
    },
    "examples": [
      {
        "arguments": {
          "x": 0
        },
        "returns": 0
      },
      {
        "arguments": {
          "x": 3.5
        },
        "returns": 3.5
      },
      {
        "arguments": {
          "x": -0.4
        },
        "returns": 0.4
      },
      {
        "arguments": {
          "x": -3.5
        },
        "returns": 3.5
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "http://mathworld.wolfram.com/AbsoluteValue.html",
        "title": "Absolute value explained by Wolfram MathWorld"
      }
    ],
    "process_graph": {
      "lt": {
        "process_id": "lt",
        "arguments": {
          "x": {
            "from_parameter": "x"
          },
          "y": 0
        }
      },
      "multiply": {
        "process_id": "multiply",
        "arguments": {
          "x": {
            "from_parameter": "x"
          },
          "y": -1
        }
      },
      "if": {
        "process_id": "if",
        "arguments": {
          "value": {
            "from_node": "lt"
          },
          "accept": {
            "from_node": "multiply"
          },
          "reject": {
            "from_parameter": "x"
          }
        },
        "result": true
      }
    }
  },
  {
    "id": "add_dimension",
    "summary": "Add a new dimension",
    "description": "Adds a new named dimension to the data cube.\n\nAfterwards, the dimension can be referenced with the specified `name`. If a dimension with the specified name exists, the process fails with a `DimensionExists` error. The dimension label of the dimension is set to the specified `label`.",
    "categories": [
      "cubes"
    ],
    "parameters": [
      {
        "name": "data",
        "description": "A data cube to add the dimension to.",
        "schema": {
          "type": "object",
          "subtype": "raster-cube"
        }
      },
      {
        "name": "name",
        "description": "Name for the dimension.",
        "schema": {
          "type": "string"
        }
      },
      {
        "name": "label",
        "description": "A dimension label.",
        "schema": [
          {
            "type": "number"
          },
          {
            "type": "string"
          }
        ]
      },
      {
        "name": "type",
        "description": "The type of dimension, defaults to `other`.",
        "schema": {
          "type": "string",
          "enum": [
            "spatial",
            "temporal",
            "bands",
            "other"
          ]
        },
        "default": "other",
        "optional": true
      }
    ],
    "returns": {
      "description": "The data cube with a newly added dimension.",
      "schema": {
        "type": "object",
        "subtype": "raster-cube"
      }
    },
    "exceptions": {
      "DimensionExists": {
        "message": "A dimension with the specified name already exists."
      }
    }
  },
  {
    "id": "add",
    "summary": "Addition of two numbers",
    "description": "Sums up the two numbers `x` and `y` (*x + y*) and returns the computed sum.\n\nNo-data values are taken into account so that `null` is returned if any element is such a value.\n\nThe computations follow [IEEE Standard 754](https://ieeexplore.ieee.org/document/8766229) whenever the processing environment supports it.",
    "categories": [
      "math"
    ],
    "parameters": [
      {
        "name": "x",
        "description": "The first summand.",
        "schema": {
          "type": [
            "number",
            "null"
          ]
        }
      },
      {
        "name": "y",
        "description": "The second summand.",
        "schema": {
          "type": [
            "number",
            "null"
          ]
        }
      }
    ],
    "returns": {
      "description": "The computed sum of the two numbers.",
      "schema": {
        "type": [
          "number",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "x": 5,
          "y": 2.5
        },
        "returns": 7.5
      },
      {
        "arguments": {
          "x": -2,
          "y": -4
        },
        "returns": -6
      },
      {
        "arguments": {
          "x": 1,
          "y": null
        },
        "returns": null
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "http://mathworld.wolfram.com/Sum.html",
        "title": "Sum explained by Wolfram MathWorld"
      },
      {
        "rel": "about",
        "href": "https://ieeexplore.ieee.org/document/8766229",
        "title": "IEEE Standard 754-2019 for Floating-Point Arithmetic"
      }
    ],
    "process_graph": {
      "sum": {
        "process_id": "sum",
        "arguments": {
          "data": [
            {
              "from_parameter": "x"
            },
            {
              "from_parameter": "y"
            }
          ],
          "ignore_nodata": false
        },
        "result": true
      }
    }
  },
  {
    "id": "aggregate_spatial_binary",
    "summary": "Zonal statistics for geometries by binary aggregation",
    "description": "Aggregates statistics for one or more geometries (e.g. zonal statistics for polygons) over the spatial dimensions. This process consecutively passes a pair of values to the reducer. This may be better suited especially for UDFs in case the number of values gets too large to be processed at once. In contrast, ``aggregate_spatial()`` passes a list of values.\n\n- For **polygons**, the process considers all pixels for which the point at the pixel center intersects with the corresponding polygon (as defined in the Simple Features standard by the OGC).\n- For **points**, the process considers the closest pixel center.\n- For **lines** (line strings), the process considers all the pixels whose centers are closest to at least one point on the line.\n\nThe data cube must have been reduced to only contain two raster dimensions and a third dimension the values are aggregated for, for example the temporal dimension to get a time series. Otherwise this process fails with the `TooManyDimensions` error.\n\nThe number of total and valid pixels is returned together with the calculated values.",
    "categories": [
      "cubes",
      "aggregate & resample"
    ],
    "experimental": true,
    "parameters": [
      {
        "name": "data",
        "description": "A raster data cube. The data cube implicitly gets restricted to the bounds of the geometries as if ``filter_spatial()`` would have been used with the same values for the corresponding parameters immediately before this process.",
        "schema": {
          "type": "object",
          "subtype": "raster-cube"
        }
      },
      {
        "name": "geometries",
        "description": "Geometries as GeoJSON on which the aggregation will be based.",
        "schema": {
          "type": "object",
          "subtype": "geojson"
        }
      },
      {
        "name": "reducer",
        "description": "A reduction operator to be applied consecutively on tuples of values. It must be both associative and commutative as the execution may be executed in parallel and therefore the order of execution is arbitrary. The reduction operator may be a single process such as ``multiply()`` or consist of multiple sub-processes.",
        "schema": {
          "type": "object",
          "subtype": "process-graph",
          "parameters": [
            {
              "name": "x",
              "description": "The first value.",
              "schema": {
                "description": "Any data type."
              }
            },
            {
              "name": "y",
              "description": "The second value.",
              "schema": {
                "description": "Any data type."
              }
            },
            {
              "name": "context",
              "description": "Additional data passed by the user.",
              "schema": {
                "description": "Any data type."
              },
              "optional": true,
              "default": null
            }
          ]
        }
      },
      {
        "name": "target_dimension",
        "description": "The new dimension name to be used for storing the results. Defaults to `result`.",
        "schema": {
          "type": "string"
        },
        "default": "result",
        "optional": true
      },
      {
        "name": "context",
        "description": "Additional data to be passed to the reducer.",
        "schema": {
          "description": "Any data type."
        },
        "optional": true,
        "default": null
      }
    ],
    "returns": {
      "description": "A vector data cube with the computed results and restricted to the bounds of the geometries.\n\nThe computed value is stored in dimension with the name that was specified in the parameter `target_dimension`.\n\nThe computation also stores information about the total count of pixels (valid + invalid pixels) and the number of valid pixels (see ``is_valid()``) for each geometry. These values are stored as new dimension with a dimension name derived from `target_dimension` by adding the suffix `_meta`. The new dimension has the dimension labels `total_count` and `valid_count`.",
      "schema": {
        "type": "object",
        "subtype": "vector-cube"
      }
    },
    "exceptions": {
      "TooManyDimensions": {
        "message": "The number of dimensions must be reduced to three for 'aggregate_spatial_binary'."
      }
    },
    "links": [
      {
        "href": "https://open-eo.github.io/openeo-api/glossary/#aggregation-and-resampling",
        "rel": "about",
        "title": "Aggregation explained in the openEO glossary"
      },
      {
        "href": "http://www.opengeospatial.org/standards/sfa",
        "rel": "about",
        "title": "Simple Features standard by the OGC"
      },
      {
        "rel": "about",
        "href": "https://en.wikipedia.org/wiki/Reduction_Operator",
        "title": "Background information on reduction operators (binary reducers) by Wikipedia"
      }
    ]
  },
  {
    "id": "aggregate_spatial",
    "summary": "Zonal statistics for geometries",
    "description": "Aggregates statistics for one or more geometries (e.g. zonal statistics for polygons) over the spatial dimensions. This process passes a list of values to the reducer. In contrast, ``aggregate_spatial_binary()`` passes two values, which may be better suited especially for UDFs in case the number of values gets too large to be processed at once.\n\n- For **polygons**, the process considers all pixels for which the point at the pixel center intersects with the corresponding polygon (as defined in the Simple Features standard by the OGC).\n- For **points**, the process considers the closest pixel center.\n- For **lines** (line strings), the process considers all the pixels whose centers are closest to at least one point on the line.\n\nThus, pixels may be part of multiple geometries and be part of multiple aggregations.\n\nThe data cube must have been reduced to only contain two spatial dimensions and a third dimension the values are aggregated for, for example the temporal dimension to get a time series. Otherwise this process fails with the `TooManyDimensions` error.\n\nThe number of total and valid pixels is returned together with the calculated values.",
    "categories": [
      "cubes",
      "aggregate & resample"
    ],
    "parameters": [
      {
        "name": "data",
        "description": "A raster data cube. The data cube implicitly gets restricted to the bounds of the geometries as if ``filter_spatial()`` would have been used with the same values for the corresponding parameters immediately before this process.",
        "schema": {
          "type": "object",
          "subtype": "raster-cube"
        }
      },
      {
        "name": "geometries",
        "description": "Geometries as GeoJSON on which the aggregation will be based.",
        "schema": {
          "type": "object",
          "subtype": "geojson"
        }
      },
      {
        "name": "reducer",
        "description": "A reducer to be applied on all values of each geometry. A reducer is a single process such as ``mean()`` or a set of processes, which computes a single value for a list of values, see the category 'reducer' for such processes.",
        "schema": {
          "type": "object",
          "subtype": "process-graph",
          "parameters": [
            {
              "name": "data",
              "description": "An array with elements of any type.",
              "schema": {
                "type": "array",
                "items": {
                  "description": "Any data type."
                }
              }
            },
            {
              "name": "context",
              "description": "Additional data passed by the user.",
              "schema": {
                "description": "Any data type."
              },
              "optional": true,
              "default": null
            }
          ]
        }
      },
      {
        "name": "target_dimension",
        "description": "The new dimension name to be used for storing the results. Defaults to `result`.",
        "schema": {
          "type": "string"
        },
        "default": "result",
        "optional": true
      },
      {
        "name": "context",
        "description": "Additional data to be passed to the reducer.",
        "schema": {
          "description": "Any data type."
        },
        "optional": true,
        "default": null
      }
    ],
    "returns": {
      "description": "A vector data cube with the computed results and restricted to the bounds of the geometries.\n\nThe computed value is stored in dimension with the name that was specified in the parameter `target_dimension`.\n\nThe computation also stores information about the total count of pixels (valid + invalid pixels) and the number of valid pixels (see ``is_valid()``) for each geometry. These values are stored as new dimension with a dimension name derived from `target_dimension` by adding the suffix `_meta`. The new dimension has the dimension labels `total_count` and `valid_count`.",
      "schema": {
        "type": "object",
        "subtype": "vector-cube"
      }
    },
    "exceptions": {
      "TooManyDimensions": {
        "message": "The number of dimensions must be reduced to three for 'aggregate_spatial'."
      }
    },
    "links": [
      {
        "href": "https://open-eo.github.io/openeo-api/glossary/#aggregation-and-resampling",
        "rel": "about",
        "title": "Aggregation explained in the openEO glossary"
      },
      {
        "href": "http://www.opengeospatial.org/standards/sfa",
        "rel": "about",
        "title": "Simple Features standard by the OGC"
      }
    ]
  },
  {
    "id": "aggregate_temporal_period",
    "summary": "Temporal aggregations based on calendar hierarchies",
    "description": "Computes a temporal aggregation based on calendar hierarchies such as years, months or seasons. For other calendar hierarchies ``aggregate_temporal()`` can be used.\n\nFor each interval, all data along the dimension will be passed through the reducer.\n\nIf the dimension is not set or is set to `null`, the data cube is expected to only have one temporal dimension.",
    "categories": [
      "aggregate & resample",
      "climatology",
      "cubes"
    ],
    "parameters": [
      {
        "name": "data",
        "description": "A data cube.",
        "schema": {
          "type": "object",
          "subtype": "raster-cube"
        }
      },
      {
        "name": "period",
        "description": "The time intervals to aggregate. The following pre-defined values are available:\n\n* `hour`: Hour of the day\n* `day`: Day of the year\n* `week`: Week of the year\n* `month`: Month of the year\n* `year`: Proleptic years\n* `season`: Refers to three month periods of the calendar seasons (December - February, March - May, June - August, September - November).\n* `tropical-season`: Refers to the six month periods of the tropical seasons (November - April, May - October).",
        "schema": {
          "type": "string",
          "enum": [
            "hour",
            "day",
            "week",
            "month",
            "year",
            "season",
            "tropical-season"
          ]
        }
      },
      {
        "name": "reducer",
        "description": "A reducer to be applied on all values along the specified dimension. A reducer is a single process such as ``mean()`` or a set of processes, which computes a single value for a list of values, see the category 'reducer' for such processes.",
        "schema": {
          "type": "object",
          "subtype": "process-graph",
          "parameters": [
            {
              "name": "data",
              "description": "A labeled array with elements of any type.",
              "schema": {
                "type": "array",
                "subtype": "labeled-array",
                "items": {
                  "description": "Any data type."
                }
              }
            },
            {
              "name": "context",
              "description": "Additional data passed by the user.",
              "schema": {
                "description": "Any data type."
              },
              "optional": true,
              "default": null
            }
          ]
        }
      },
      {
        "name": "dimension",
        "description": "The name of the temporal dimension for aggregation. All data along the dimension will be passed through the specified reducer. If the dimension is not set or set to `null`, the data cube is expected to only have one temporal dimension. Fails with a `TooManyDimensions` error if it has more dimensions. Fails with a `DimensionNotAvailable` error if the specified dimension does not exist.\n\n**Note:** The default dimensions a data cube provides are described in the collection's metadata field `cube:dimensions`.",
        "schema": {
          "type": [
            "string",
            "null"
          ]
        },
        "default": null,
        "optional": true
      },
      {
        "name": "context",
        "description": "Additional data to be passed to the reducer.",
        "schema": {
          "description": "Any data type."
        },
        "optional": true,
        "default": null
      }
    ],
    "returns": {
      "description": "A data cube with potentially lower resolution and cardinality, but the same number of dimensions as the original data cube. The specified temporal dimension has the following dimension labels (`YYYY` = four-digit year, `MM` = two-digit month, `DD` two-digit day of month):\n\n* `hour`: `YYYY-MM-DD-00` - `YYYY-MM-DD-23`\n* `day`: `YYYY-001` - `YYYY-365`\n* `week`: `YYYY-01` - `YYYY-52`\n* `month`: `YYYY-01` - `YYYY-12`\n* `year`: `YYYY`\n* `season`: `YYYY-djf` (December - February), `YYYY-mam` (March - May), `YYYY-jja` (June - August), `YYYY-son` (September - November).\n* `tropical-season`: `YYYY-ndjfma` (November - April), `YYYY-mjjaso` (May - October).",
      "schema": {
        "type": "object",
        "subtype": "raster-cube"
      }
    },
    "exceptions": {
      "TooManyDimensions": {
        "message": "The data cube contains multiple temporal dimensions. The parameter `dimension` must be specified."
      },
      "DimensionNotAvailable": {
        "message": "A dimension with the specified name does not exist."
      },
      "DistinctDimensionLabelsRequired": {
        "message": "The dimension labels have duplicate values. Distinct labels must be specified."
      }
    },
    "links": [
      {
        "href": "https://open-eo.github.io/openeo-api/glossary/#aggregation-and-resampling",
        "rel": "about",
        "title": "Aggregation explained in the openEO glossary"
      }
    ]
  },
  {
    "id": "aggregate_temporal",
    "summary": "Temporal aggregations",
    "description": "Computes a temporal aggregation based on an array of temporal intervals.\n\nFor common regular calendar hierarchies such as year, month, week or seasons ``aggregate_temporal_period()`` can be used. Other calendar hierarchies must be transformed into specific intervals by the clients.\n\nFor each interval, all data along the dimension will be passed through the reducer.\n\nThe computed values will be projected to the labels. If no labels are specified, the start of the temporal interval will be used as label for the corresponding values. In case of a conflict (i.e. the user-specified values for the start times of the temporal intervals are not distinct), the user-defined labels must be specified in the parameter `labels` as otherwise a `DistinctDimensionLabelsRequired` error would be thrown. The number of user-defined labels and the number of intervals need to be equal.\n\nIf the dimension is not set or is set to `null`, the data cube is expected to only have one temporal dimension.",
    "categories": [
      "cubes",
      "aggregate & resample"
    ],
    "parameters": [
      {
        "name": "data",
        "description": "A data cube.",
        "schema": {
          "type": "object",
          "subtype": "raster-cube"
        }
      },
      {
        "name": "intervals",
        "description": "Left-closed temporal intervals, which are allowed to overlap. Each temporal interval in the array has exactly two elements:\n\n1. The first element is the start of the temporal interval. The specified instance in time is **included** in the interval.\n2. The second element is the end of the temporal interval. The specified instance in time is **excluded** from the interval.\n\nThe specified temporal strings follow [RFC 3339](https://tools.ietf.org/html/rfc3339). Although [RFC 3339 prohibits the hour to be '24'](https://tools.ietf.org/html/rfc3339#section-5.7), **this process allows the value '24' for the hour** of an end time in order to make it possible that left-closed time intervals can fully cover the day.",
        "schema": {
          "type": "array",
          "subtype": "temporal-intervals",
          "minItems": 1,
          "items": {
            "type": "array",
            "subtype": "temporal-interval",
            "minItems": 2,
            "maxItems": 2,
            "items": {
              "anyOf": [
                {
                  "type": "string",
                  "format": "date-time",
                  "subtype": "date-time"
                },
                {
                  "type": "string",
                  "format": "date",
                  "subtype": "date"
                },
                {
                  "type": "string",
                  "format": "time",
                  "subtype": "time"
                },
                {
                  "type": "null"
                }
              ]
            }
          },
          "examples": [
            [
              [
                "2015-01-01",
                "2016-01-01"
              ],
              [
                "2016-01-01",
                "2017-01-01"
              ],
              [
                "2017-01-01",
                "2018-01-01"
              ]
            ],
            [
              [
                "00:00:00Z",
                "12:00:00Z"
              ],
              [
                "12:00:00Z",
                "24:00:00Z"
              ]
            ]
          ]
        }
      },
      {
        "name": "reducer",
        "description": "A reducer to be applied on all values along the specified dimension. A reducer is a single process such as ``mean()`` or a set of processes, which computes a single value for a list of values, see the category 'reducer' for such processes.",
        "schema": {
          "type": "object",
          "subtype": "process-graph",
          "parameters": [
            {
              "name": "data",
              "description": "A labeled array with elements of any type.",
              "schema": {
                "type": "array",
                "subtype": "labeled-array",
                "items": {
                  "description": "Any data type."
                }
              }
            },
            {
              "name": "context",
              "description": "Additional data passed by the user.",
              "schema": {
                "description": "Any data type."
              },
              "optional": true,
              "default": null
            }
          ]
        }
      },
      {
        "name": "labels",
        "description": "Distinct labels for the intervals, which can contain dates and/or times. Is only required to be specified if the values for the start of the temporal intervals are not distinct and thus the default labels would not be unique. The number of labels and the number of groups need to be equal.",
        "schema": {
          "type": "array",
          "items": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "string"
              }
            ]
          }
        },
        "default": [],
        "optional": true
      },
      {
        "name": "dimension",
        "description": "The name of the temporal dimension for aggregation. All data along the dimension will be passed through the specified reducer. If the dimension is not set or set to `null`, the data cube is expected to only have one temporal dimension. Fails with a `TooManyDimensions` error if it has more dimensions. Fails with a `DimensionNotAvailable` error if the specified dimension does not exist.\n\n**Note:** The default dimensions a data cube provides are described in the collection's metadata field `cube:dimensions`.",
        "schema": {
          "type": [
            "string",
            "null"
          ]
        },
        "default": null,
        "optional": true
      },
      {
        "name": "context",
        "description": "Additional data to be passed to the reducer.",
        "schema": {
          "description": "Any data type."
        },
        "optional": true,
        "default": null
      }
    ],
    "returns": {
      "description": "A data cube with potentially lower resolution and potentially lower cardinality, but the same number of dimensions as the original data cube.",
      "schema": {
        "type": "object",
        "subtype": "raster-cube"
      }
    },
    "examples": [
      {
        "process_graph": {
          "loadco1": {
            "process_id": "load_collection",
            "arguments": {
              "id": "Sentinel-2",
              "spatial_extent": {
                "from_parameter": "spatial_extent"
              },
              "temporal_extent": [
                "2015-01-01",
                "2019-01-01"
              ]
            }
          },
          "aggreg1": {
            "process_id": "aggregate_temporal",
            "arguments": {
              "data": {
                "from_node": "loadco1"
              },
              "intervals": [
                [
                  "2015-01-01",
                  "2016-01-01"
                ],
                [
                  "2016-01-01",
                  "2017-01-01"
                ],
                [
                  "2017-01-01",
                  "2018-01-01"
                ],
                [
                  "2018-01-01",
                  "2019-01-01"
                ]
              ],
              "labels": [
                "2015",
                "2016",
                "2017",
                "2018"
              ],
              "reducer": {
                "process_graph": {
                  "median1": {
                    "process_id": "mean",
                    "arguments": {
                      "data": {
                        "from_parameter": "data"
                      }
                    },
                    "result": true
                  }
                }
              }
            },
            "result": true
          }
        }
      }
    ],
    "exceptions": {
      "TooManyDimensions": {
        "message": "The data cube contains multiple temporal dimensions. The parameter `dimension` must be specified."
      },
      "DimensionNotAvailable": {
        "message": "A dimension with the specified name does not exist."
      },
      "DistinctDimensionLabelsRequired": {
        "message": "The dimension labels have duplicate values. Distinct labels must be specified."
      }
    },
    "links": [
      {
        "href": "https://open-eo.github.io/openeo-api/glossary/#aggregation-and-resampling",
        "rel": "about",
        "title": "Aggregation explained in the openEO glossary"
      }
    ]
  },
  {
    "id": "all",
    "summary": "Are all of the values true?",
    "description": "Checks if **all** of the values are true. Evaluates all values from the first to the last element and stops once the outcome is unambiguous.\n\nIf only one value is given, the process evaluates to the given value. If no value is given (i.e. the array is empty) the process returns `null`.\n\nBy default all no-data values are ignored so that the process returns `null` if all values are no-data, `true` if all other values are true and `false` otherwise. Setting the `ignore_nodata` flag to `false` considers no-data values so that `null` is a valid logical object. If a component is `null`, the result will be `null` if the outcome is ambiguous. See the following truth table:\n\n```\n      || null  | false | true\n----- || ----- | ----- | -----\nnull  || null  | false | null\nfalse || false | false | false\ntrue  || null  | false | true\n```",
    "categories": [
      "logic",
      "reducer"
    ],
    "parameters": [
      {
        "name": "values",
        "description": "A set of boolean values.",
        "schema": {
          "type": "array",
          "items": {
            "type": [
              "boolean",
              "null"
            ]
          }
        }
      },
      {
        "name": "ignore_nodata",
        "description": "Indicates whether no-data values are ignored or not and ignores them by default.",
        "schema": {
          "type": "boolean"
        },
        "default": true,
        "optional": true
      }
    ],
    "returns": {
      "description": "Boolean result of the logical operation.",
      "schema": {
        "type": [
          "boolean",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "values": [
            false,
            null
          ]
        },
        "returns": false
      },
      {
        "arguments": {
          "values": [
            true,
            null
          ]
        },
        "returns": true
      },
      {
        "arguments": {
          "values": [
            false,
            null
          ],
          "ignore_nodata": false
        },
        "returns": false
      },
      {
        "arguments": {
          "values": [
            true,
            null
          ],
          "ignore_nodata": false
        },
        "returns": null
      },
      {
        "arguments": {
          "values": [
            true,
            false,
            true,
            false
          ]
        },
        "returns": false
      },
      {
        "arguments": {
          "values": [
            true,
            false
          ]
        },
        "returns": false
      },
      {
        "arguments": {
          "values": [
            true,
            true
          ]
        },
        "returns": true
      },
      {
        "arguments": {
          "values": [
            true
          ]
        },
        "returns": true
      },
      {
        "arguments": {
          "values": [
            null
          ],
          "ignore_nodata": false
        },
        "returns": null
      },
      {
        "arguments": {
          "values": []
        },
        "returns": null
      }
    ]
  },
  {
    "id": "and",
    "summary": "Logical AND",
    "description": "Checks if **both** values are true.\n\nEvaluates parameter `x` before `y` and stops once the outcome is unambiguous. If any argument is `null`, the result will be `null` if the outcome is ambiguous.\n\n**Truth table:**\n\n```\na \\ b || null  | false | true\n----- || ----- | ----- | -----\nnull  || null  | false | null\nfalse || false | false | false\ntrue  || null  | false | true\n```",
    "categories": [
      "logic"
    ],
    "parameters": [
      {
        "name": "x",
        "description": "A boolean value.",
        "schema": {
          "type": [
            "boolean",
            "null"
          ]
        }
      },
      {
        "name": "y",
        "description": "A boolean value.",
        "schema": {
          "type": [
            "boolean",
            "null"
          ]
        }
      }
    ],
    "returns": {
      "description": "Boolean result of the logical AND.",
      "schema": {
        "type": [
          "boolean",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "x": true,
          "y": true
        },
        "returns": true
      },
      {
        "arguments": {
          "x": true,
          "y": false
        },
        "returns": false
      },
      {
        "arguments": {
          "x": false,
          "y": false
        },
        "returns": false
      },
      {
        "arguments": {
          "x": false,
          "y": null
        },
        "returns": false
      },
      {
        "arguments": {
          "x": true,
          "y": null
        },
        "returns": null
      }
    ],
    "process_graph": {
      "all": {
        "process_id": "all",
        "arguments": {
          "data": [
            {
              "from_parameter": "x"
            },
            {
              "from_parameter": "y"
            }
          ],
          "ignore_nodata": false
        },
        "result": true
      }
    }
  },
  {
    "id": "anomaly",
    "summary": "Computes anomalies",
    "description": "Computes anomalies based on normals for temporal periods. It compares the data for each label in the temporal dimension with the corresponding data in the normals data cube by subtracting the normal from the data.",
    "categories": [
      "climatology",
      "cube",
      "math"
    ],
    "parameters": [
      {
        "name": "data",
        "description": "A data cube with exactly one temporal dimension and the following dimension labels for the given period (`YYYY` = four-digit year, `MM` = two-digit month, `DD` two-digit day of month):\n\n* `hour`: `YYYY-MM-DD-00` - `YYYY-MM-DD-23`\n* `day`: `YYYY-001` - `YYYY-365`\n* `week`: `YYYY-01` - `YYYY-52`\n* `month`: `YYYY-01` - `YYYY-12`\n* `year`: `YYYY`\n* `season`: `YYYY-djf` (December - February), `YYYY-mam` (March - May), `YYYY-jja` (June - August), `YYYY-son` (September - November)\n* `tropical-season`: `YYYY-ndjfma` (November - April), `YYYY-mjjaso` (May - October)\n\n``aggregate_temporal_period()`` can compute such a data cube.",
        "schema": {
          "type": "object",
          "subtype": "raster-cube"
        }
      },
      {
        "name": "normals",
        "description": "A data cube with normals, e.g. daily, monthly or yearly values computed from a process such as ``climatological_normal()``. Must contain exactly one temporal dimension with the following dimension labels for the given period:\n\n* `hour`: `00` - `23`\n* `day`: `001` - `365`\n* `week`: `01` - `52`\n* `month`: `01` - `12`\n* `year`: Four-digit year numbers\n* `single-period` / `climatology-period`: A single dimension label with any name is expected.\n* `season`: `djf` (December - February), `mam` (March - May), `jja` (June - August), `son` (September - November)\n* `tropical-season`: `ndjfma` (November - April), `mjjaso` (May - October)",
        "schema": {
          "type": "object",
          "subtype": "raster-cube"
        }
      },
      {
        "name": "period",
        "description": "Specifies the time intervals available in the normals data cube. The following options are available:\n\n* `hour`: Hour of the day\n* `day`: Day of the year\n* `week`: Week of the year\n* `month`: Month of the year\n* `year`: Proleptic years\n* `season`: Refers to three month periods of the calendar seasons (December - February, March - May, June - August, September - November).\n* `tropical-season`: Refers to the six month periods of the tropical seasons (November - April, May - October).",
        "schema": {
          "type": "string",
          "enum": [
            "hour",
            "day",
            "week",
            "month",
            "year",
            "single-period",
            "climatology-period",
            "season",
            "tropical-season"
          ]
        }
      }
    ],
    "returns": {
      "description": "A data cube. The cardinality, resolution, the number of dimensions and the dimension labels are the same as for the original data cube.",
      "schema": {
        "type": "object",
        "subtype": "raster-cube"
      }
    }
  },
  {
    "id": "any",
    "summary": "Is at least one value true?",
    "description": "Checks if **any** (i.e. at least one) value is `true`. Evaluates all values from the first to the last element and stops once the outcome is unambiguous.\n\nIf only one value is given, the process evaluates to the given value. If no value is given (i.e. the array is empty) the process returns `null`.\n\nBy default all no-data values are ignored so that the process returns `null` if all values are no-data, `true` if at least one of the other values is true and `false` otherwise. Setting the `ignore_nodata` flag to `false` considers no-data values so that `null` is a valid logical object. If a component is `null`, the result will be `null` if the outcome is ambiguous. See the following truth table:\n\n```\n      || null | false | true\n----- || ---- | ----- | ----\nnull  || null | null  | true\nfalse || null | false | true\ntrue  || true | true  | true\n```",
    "categories": [
      "logic",
      "reducer"
    ],
    "parameters": [
      {
        "name": "values",
        "description": "A set of boolean values.",
        "schema": {
          "type": "array",
          "items": {
            "type": [
              "boolean",
              "null"
            ]
          }
        }
      },
      {
        "name": "ignore_nodata",
        "description": "Indicates whether no-data values are ignored or not and ignores them by default.",
        "schema": {
          "type": "boolean"
        },
        "default": true,
        "optional": true
      }
    ],
    "returns": {
      "description": "Boolean result of the logical operation.",
      "schema": {
        "type": [
          "boolean",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "values": [
            false,
            null
          ]
        },
        "returns": false
      },
      {
        "arguments": {
          "values": [
            true,
            null
          ]
        },
        "returns": true
      },
      {
        "arguments": {
          "values": [
            false,
            null
          ],
          "ignore_nodata": false
        },
        "returns": null
      },
      {
        "arguments": {
          "values": [
            true,
            null
          ],
          "ignore_nodata": false
        },
        "returns": true
      },
      {
        "arguments": {
          "values": [
            true,
            false,
            true,
            false
          ]
        },
        "returns": true
      },
      {
        "arguments": {
          "values": [
            true,
            false
          ]
        },
        "returns": true
      },
      {
        "arguments": {
          "values": [
            false,
            false
          ]
        },
        "returns": false
      },
      {
        "arguments": {
          "values": [
            true
          ]
        },
        "returns": true
      },
      {
        "arguments": {
          "values": [
            null
          ],
          "ignore_nodata": false
        },
        "returns": null
      },
      {
        "arguments": {
          "values": []
        },
        "returns": null
      }
    ]
  },
  {
    "id": "apply_dimension",
    "summary": "Apply a process to pixels along a dimension",
    "description": "Applies a process to all pixel values along a dimension of a raster data cube. For example, if the temporal dimension is specified the process will work on a time series of pixel values.\n\nThe process ``reduce_dimension()`` also applies a process to pixel values along a dimension, but drops the dimension afterwards. The process ``apply()`` applies a process to each pixel value in the data cube.\n\nThe target dimension is the source dimension if not specified otherwise in the `target_dimension` parameter. The pixel values in the target dimension get replaced by the computed pixel values. The name, type and reference system are preserved.\n\nThe dimension labels are preserved when the target dimension is the source dimension and the number of pixel values in the source dimension is equal to the number of values computed by the process. Otherwise, the dimension labels will be incrementing integers starting from zero, which can be changed using ``rename_labels()`` afterwards. The number of labels will equal to the number of values computed by the process.",
    "categories": [
      "cubes"
    ],
    "parameters": [
      {
        "name": "data",
        "description": "A data cube.",
        "schema": {
          "type": "object",
          "subtype": "raster-cube"
        }
      },
      {
        "name": "process",
        "description": "Process to be applied on all pixel values. The specified process needs to accept an array as parameter and must return an array with least one element. A process may consist of multiple sub-processes.",
        "schema": {
          "type": "object",
          "subtype": "process-graph",
          "parameters": [
            {
              "name": "data",
              "description": "A labeled array with elements of any type.",
              "schema": {
                "type": "array",
                "subtype": "labeled-array",
                "items": {
                  "description": "Any data type."
                }
              }
            },
            {
              "name": "context",
              "description": "Additional data passed by the user.",
              "schema": {
                "description": "Any data type."
              },
              "optional": true,
              "default": null
            }
          ]
        }
      },
      {
        "name": "dimension",
        "description": "The name of the source dimension to apply the process on. Fails with a `DimensionNotAvailable` error if the specified dimension does not exist.",
        "schema": {
          "type": "string"
        }
      },
      {
        "name": "target_dimension",
        "description": "The name of the target dimension or `null` (the default) to use the source dimension specified in the parameter `dimension`.\n\nBy specifying a target dimension, the source dimension is removed. The target dimension with the specified name and the type `other` (see ``add_dimension()``) is created, if if doesn't exist yet.",
        "schema": {
          "type": [
            "string",
            "null"
          ]
        },
        "default": null,
        "optional": true
      },
      {
        "name": "context",
        "description": "Additional data to be passed to the process.",
        "schema": {
          "description": "Any data type."
        },
        "optional": true,
        "default": null
      }
    ],
    "returns": {
      "description": "A data cube with the newly computed values for the specified. The resolution and the number of dimensions are the same as for the original data cube.",
      "schema": {
        "type": "object",
        "subtype": "raster-cube"
      }
    },
    "exceptions": {
      "DimensionNotAvailable": {
        "message": "A dimension with the specified name does not exist."
      }
    }
  },
  {
    "id": "apply_kernel",
    "summary": "Apply a kernel to compute pixel-wise values",
    "description": "Applies a 2D convolution (i.e. a focal operation with a weighted kernel) on the horizontal spatial dimensions (axes `x` and `y`) of the data cube.\n\nEach value in the kernel is multiplied with the corresponding pixel value and all products are summed up afterwards. The sum is then multiplied with the factor.",
    "categories": [
      "cubes",
      "math > image filter"
    ],
    "parameters": [
      {
        "name": "data",
        "description": "A data cube.",
        "schema": {
          "type": "object",
          "subtype": "raster-cube"
        }
      },
      {
        "name": "kernel",
        "description": "A two-dimensional weighted kernel. Each dimension of the kernel must have an uneven number of elements, otherwise the process throws a `KernelDimensionsUneven` error.",
        "schema": {
          "description": "A two-dimensional array of numbers.",
          "type": "array",
          "subtype": "kernel",
          "items": {
            "type": "array",
            "items": {
              "type": "number"
            }
          }
        }
      },
      {
        "name": "factor",
        "description": "A factor that is multiplied to each value after the kernel has been applied.\n\nThis is basically a shortcut for explicitly multiplying each value by a factor afterwards, which is often required for some kernel-based algorithms such as the Gaussian blur.",
        "schema": {
          "type": "number"
        },
        "default": 1,
        "optional": true
      }
    ],
    "returns": {
      "description": "A data cube with the newly computed values. The resolution, cardinality and the number of dimensions are the same as for the original data cube.",
      "schema": {
        "type": "object",
        "subtype": "raster-cube"
      }
    },
    "exceptions": {
      "KernelDimensionsUneven": {
        "message": "Each dimension of the kernel must have an uneven number of elements."
      }
    },
    "links": [
      {
        "rel": "about",
        "href": "http://www.songho.ca/dsp/convolution/convolution.html",
        "title": "Convolutions explained"
      },
      {
        "rel": "about",
        "href": "http://www.songho.ca/dsp/convolution/convolution2d_example.html",
        "title": "Example of 2D Convolution"
      }
    ]
  },
  {
    "id": "apply",
    "summary": "Apply a process to each pixel",
    "description": "Applies a *unary* process to each pixel value in the data cube (i.e. a local operation). A unary process takes a single value and returns a single value, for example ``abs()`` or ``linear_scale_range()``. In contrast, the process ``apply_dimension()`` applies a process to all pixel values along a particular dimension.",
    "categories": [
      "cubes"
    ],
    "parameters": [
      {
        "name": "data",
        "description": "A data cube.",
        "schema": {
          "type": "object",
          "subtype": "raster-cube"
        }
      },
      {
        "name": "process",
        "description": "A unary process to be applied on each value, may consist of multiple sub-processes.",
        "schema": {
          "type": "object",
          "subtype": "process-graph",
          "parameters": [
            {
              "name": "x",
              "description": "The value to process.",
              "schema": {
                "description": "Any data type."
              }
            },
            {
              "name": "context",
              "description": "Additional data passed by the user.",
              "schema": {
                "description": "Any data type."
              },
              "optional": true,
              "default": null
            }
          ]
        }
      },
      {
        "name": "context",
        "description": "Additional data to be passed to the process.",
        "schema": {
          "description": "Any data type."
        },
        "optional": true,
        "default": null
      }
    ],
    "returns": {
      "description": "A data cube with the newly computed values. The resolution, cardinality and the number of dimensions are the same as for the original data cube.",
      "schema": {
        "type": "object",
        "subtype": "raster-cube"
      }
    }
  },
  {
    "id": "arccos",
    "summary": "Inverse cosine",
    "description": "Computes the arc cosine of `x`. The arc cosine is the inverse function of the cosine so that *arccos(cos(x)) = x*.\n\nWorks on radians only.\nThe no-data value `null` is passed through and therefore gets propagated.",
    "categories": [
      "math > trigonometric"
    ],
    "parameters": [
      {
        "name": "x",
        "description": "A number.",
        "schema": {
          "type": [
            "number",
            "null"
          ]
        }
      }
    ],
    "returns": {
      "description": "The computed angle in radians.",
      "schema": {
        "type": [
          "number",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "x": 1
        },
        "returns": 0
      },
      {
        "process_graph": {
          "cos1": {
            "process_id": "cos",
            "arguments": {
              "x": 0.5
            }
          },
          "arccos1": {
            "process_id": "arccos",
            "arguments": {
              "x": {
                "from_node": "cos1"
              }
            },
            "result": true
          }
        },
        "returns": 0.5
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "http://mathworld.wolfram.com/InverseCosine.html",
        "title": "Inverse cosine explained by Wolfram MathWorld"
      }
    ]
  },
  {
    "id": "arcosh",
    "summary": "Inverse hyperbolic cosine",
    "description": "Computes the inverse hyperbolic cosine of `x`. It is the inverse function of the hyperbolic cosine so that *arcosh(cosh(x)) = x*.\n\nWorks on radians only.\nThe no-data value `null` is passed through and therefore gets propagated.",
    "categories": [
      "math > trigonometric"
    ],
    "parameters": [
      {
        "name": "x",
        "description": "A number.",
        "schema": {
          "type": [
            "number",
            "null"
          ]
        }
      }
    ],
    "returns": {
      "description": "The computed angle in radians.",
      "schema": {
        "type": [
          "number",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "x": 1
        },
        "returns": 0
      },
      {
        "process_graph": {
          "cosh1": {
            "process_id": "cosh",
            "arguments": {
              "x": 0.5
            }
          },
          "arccosh1": {
            "process_id": "arcosh",
            "arguments": {
              "x": {
                "from_node": "cosh1"
              }
            },
            "result": true
          }
        },
        "returns": 0.5
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "http://mathworld.wolfram.com/InverseHyperbolicCosine.html",
        "title": "Inverse hyperbolic cosine explained by Wolfram MathWorld"
      }
    ]
  },
  {
    "id": "arcsin",
    "summary": "Inverse sine",
    "description": "Computes the arc sine of `x`. The arc sine is the inverse function of the sine so that *arcsin(sin(x)) = x*.\n\nWorks on radians only.\nThe no-data value `null` is passed through and therefore gets propagated.",
    "categories": [
      "math > trigonometric"
    ],
    "parameters": [
      {
        "name": "x",
        "description": "A number.",
        "schema": {
          "type": [
            "number",
            "null"
          ]
        }
      }
    ],
    "returns": {
      "description": "The computed angle in radians.",
      "schema": {
        "type": [
          "number",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "x": 0
        },
        "returns": 0
      },
      {
        "process_graph": {
          "sin1": {
            "process_id": "sin",
            "arguments": {
              "x": 0.5
            }
          },
          "arcsin1": {
            "process_id": "arcsin",
            "arguments": {
              "x": {
                "from_node": "sin1"
              }
            },
            "result": true
          }
        },
        "returns": 0.5
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "http://mathworld.wolfram.com/InverseSine.html",
        "title": "Inverse sine explained by Wolfram MathWorld"
      }
    ]
  },
  {
    "id": "arctan",
    "summary": "Inverse tangent",
    "description": "Computes the arc tangent of `x`. The arc tangent is the inverse function of the tangent so that *arctan(tan(x)) = x*.\n\nWorks on radians only.\nThe no-data value `null` is passed through and therefore gets propagated.",
    "categories": [
      "math > trigonometric"
    ],
    "parameters": [
      {
        "name": "x",
        "description": "A number.",
        "schema": {
          "type": [
            "number",
            "null"
          ]
        }
      }
    ],
    "returns": {
      "description": "The computed angle in radians.",
      "schema": {
        "type": [
          "number",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "x": 0
        },
        "returns": 0
      },
      {
        "process_graph": {
          "tan1": {
            "process_id": "tan",
            "arguments": {
              "x": 0.5
            }
          },
          "arctan1": {
            "process_id": "arctan",
            "arguments": {
              "x": {
                "from_node": "tan1"
              }
            },
            "result": true
          }
        },
        "returns": 0.5
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "http://mathworld.wolfram.com/InverseTangent.html",
        "title": "Inverse tangent explained by Wolfram MathWorld"
      }
    ]
  },
  {
    "id": "arctan2",
    "summary": "Inverse tangent of two numbers",
    "description": "Computes the arc tangent of two numbers `x` and `y`. It is similar to calculating the arc tangent of *y / x*, except that the signs of both arguments are used to determine the quadrant of the result.\n\nWorks on radians only.\nThe no-data value `null` is passed through and therefore gets propagated if any of the arguments is `null`.",
    "categories": [
      "math > trigonometric"
    ],
    "parameters": [
      {
        "name": "y",
        "description": "A number to be used as dividend.",
        "schema": {
          "type": [
            "number",
            "null"
          ]
        }
      },
      {
        "name": "x",
        "description": "A number to be used as divisor.",
        "schema": {
          "type": [
            "number",
            "null"
          ]
        }
      }
    ],
    "returns": {
      "description": "The computed angle in radians.",
      "schema": {
        "type": [
          "number",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "y": 0,
          "x": 0
        },
        "returns": 0
      },
      {
        "arguments": {
          "y": null,
          "x": 1.5
        },
        "returns": null
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "https://en.wikipedia.org/wiki/Atan2",
        "title": "Two-argument inverse tangent explained by Wikipedia"
      }
    ]
  },
  {
    "id": "array_apply",
    "summary": "Applies a unary process to each array element",
    "description": "Applies a **unary** process which takes a single value such as `abs` or `sqrt` to each value in the array. This is basically what other languages call either a `for each` loop or a `map` function.",
    "categories": [
      "arrays"
    ],
    "parameters": [
      {
        "name": "data",
        "description": "An array.",
        "schema": {
          "type": "array",
          "items": {
            "description": "Any data type is allowed."
          }
        }
      },
      {
        "name": "process",
        "description": "A process to be applied on each value, may consist of multiple sub-processes. The specified process must be unary meaning that it must work on a single value.",
        "schema": {
          "type": "object",
          "subtype": "process-graph",
          "parameters": [
            {
              "name": "x",
              "description": "The value of the current element being processed.",
              "schema": {
                "description": "Any data type."
              }
            },
            {
              "name": "index",
              "description": "The zero-based index of the current element being processed.",
              "schema": {
                "type": "integer"
              }
            },
            {
              "name": "label",
              "description": "The label of the current element being processed. Only populated for labeled arrays.",
              "schema": [
                {
                  "type": "number"
                },
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "optional": true
            },
            {
              "name": "context",
              "description": "Additional data passed by the user.",
              "schema": {
                "description": "Any data type."
              },
              "optional": true,
              "default": null
            }
          ]
        }
      },
      {
        "name": "context",
        "description": "Additional data to be passed to the process.",
        "schema": {
          "description": "Any data type."
        },
        "optional": true,
        "default": null
      }
    ],
    "returns": {
      "description": "An array with the newly computed values. The number of elements are the same as for the original array.",
      "schema": {
        "type": "array",
        "items": {
          "description": "Any data type is allowed."
        }
      }
    }
  },
  {
    "id": "array_contains",
    "summary": "Check whether the array contains a given value",
    "description": "Checks whether the array specified for `data` contains the value specified in `value`. Returns `true` if there's a match, otherwise `false`.\n\n**Remarks:**\n\n* To get the index or the label of the value found, use ``array_find()``.\n* All definitions for the process ``eq()`` regarding the comparison of values apply here as well. A `null` return value from ``eq()`` is handled exactly as `false` (no match).\n* Data types MUST be checked strictly, for example a string with the content *1* is not equal to the number *1*.\n* An integer *1* is equal to a floating point number *1.0* as `integer` is a sub-type of `number`. Still, this process may return unexpectedly `false` when comparing floating point numbers due to floating point inaccuracy in machine-based computation.\n* Temporal strings are treated as normal strings and MUST NOT be interpreted.\n* If the specified value is an array, object or null, the process always returns `false`. See the examples for one to check for `null` values.",
    "categories": [
      "arrays",
      "comparison"
    ],
    "parameters": [
      {
        "name": "data",
        "description": "List to find the value in.",
        "schema": {
          "type": "array",
          "items": {
            "description": "Any data type is allowed."
          }
        }
      },
      {
        "name": "value",
        "description": "Value to find in `data`.",
        "schema": {
          "description": "Any data type is allowed."
        }
      }
    ],
    "returns": {
      "description": "Returns `true` if the list contains the value, false` otherwise.",
      "schema": {
        "type": "boolean"
      }
    },
    "examples": [
      {
        "title": "Check for `null` values",
        "description": "Check whether the array contains a `null` value.",
        "process_graph": {
          "apply": {
            "process_id": "array_apply",
            "arguments": {
              "data": {
                "from_parameter": "data"
              },
              "process": {
                "process-graph": {
                  "is_null": {
                    "process_id": "is_nodata",
                    "arguments": {
                      "from_parameter": "x"
                    },
                    "result": true
                  }
                }
              }
            }
          },
          "find": {
            "process_id": "array_contains",
            "arguments": {
              "data": {
                "from_node": "apply"
              },
              "value": true
            },
            "result": true
          }
        }
      },
      {
        "arguments": {
          "data": [
            1,
            2,
            3
          ],
          "value": 2
        },
        "returns": true
      },
      {
        "arguments": {
          "data": [
            "A",
            "B",
            "C"
          ],
          "value": "b"
        },
        "returns": false
      },
      {
        "arguments": {
          "data": [
            1,
            2,
            3
          ],
          "value": "2"
        },
        "returns": false
      },
      {
        "arguments": {
          "data": [
            1,
            2,
            null
          ],
          "value": null
        },
        "returns": true
      },
      {
        "arguments": {
          "data": [
            [
              1,
              2
            ],
            [
              3,
              4
            ]
          ],
          "value": [
            1,
            2
          ]
        },
        "returns": false
      },
      {
        "arguments": {
          "data": [
            [
              1,
              2
            ],
            [
              3,
              4
            ]
          ],
          "value": 2
        },
        "returns": false
      },
      {
        "arguments": {
          "data": [
            {
              "a": "b"
            },
            {
              "c": "d"
            }
          ],
          "value": {
            "a": "b"
          }
        },
        "returns": false
      }
    ],
    "process_graph": {
      "find": {
        "process_id": "array_find",
        "arguments": {
          "data": {
            "from_parameter": "data"
          },
          "value": {
            "from_parameter": "value"
          }
        }
      },
      "is_nodata": {
        "process_id": "is_nodata",
        "arguments": {
          "x": {
            "from_node": "find"
          }
        }
      },
      "not": {
        "process_id": "not",
        "arguments": {
          "x": {
            "from_node": "is_nodata"
          }
        },
        "result": true
      }
    }
  },
  {
    "id": "array_element",
    "summary": "Get an element from an array",
    "description": "Returns the element with the specified index or label from the array.\n\nEither the parameter `index` or `label` must be specified, otherwise the `ArrayElementParameterMissing` exception is thrown. If both parameters are set the `ArrayElementParameterConflict` exception is thrown.",
    "categories": [
      "arrays"
    ],
    "parameters": [
      {
        "name": "data",
        "description": "An array.",
        "schema": {
          "type": "array",
          "items": {
            "description": "Any data type is allowed."
          }
        }
      },
      {
        "name": "index",
        "description": "The zero-based index of the element to retrieve.",
        "schema": {
          "type": "integer"
        },
        "optional": true
      },
      {
        "name": "label",
        "description": "The label of the element to retrieve.",
        "schema": [
          {
            "type": "number"
          },
          {
            "type": "string"
          }
        ],
        "optional": true
      },
      {
        "name": "return_nodata",
        "description": "By default this process throws an `ArrayElementNotAvailable` exception if the index or label is invalid. If you want to return `null` instead, set this flag to `true`.",
        "schema": {
          "type": "boolean"
        },
        "default": false,
        "optional": true
      }
    ],
    "returns": {
      "description": "The value of the requested element.",
      "schema": {
        "description": "Any data type is allowed."
      }
    },
    "exceptions": {
      "ArrayElementNotAvailable": {
        "message": "The array has no element with the specified index or label."
      },
      "ArrayElementParameterMissing": {
        "message": "The process 'array_element' requires either the 'index' or 'labels' parameter to be set."
      },
      "ArrayElementParameterConflict": {
        "message": "The process 'array_element' only allows that either the 'index' or the 'labels' parameter is set."
      }
    },
    "examples": [
      {
        "arguments": {
          "data": [
            9,
            8,
            7,
            6,
            5
          ],
          "index": 2
        },
        "returns": 7
      },
      {
        "arguments": {
          "data": [
            "A",
            "B",
            "C"
          ],
          "index": 0
        },
        "returns": "A"
      },
      {
        "arguments": {
          "data": [],
          "index": 0,
          "return_nodata": true
        },
        "returns": null
      }
    ]
  },
  {
    "id": "array_filter",
    "summary": "Filter an array based on a condition",
    "description": "Filters the array elements based on a logical expression so that afterwards an array is returned that only contains the values conforming to the condition.",
    "categories": [
      "arrays",
      "filter"
    ],
    "parameters": [
      {
        "name": "data",
        "description": "An array.",
        "schema": {
          "type": "array",
          "items": {
            "description": "Any data type is allowed."
          }
        }
      },
      {
        "name": "condition",
        "description": "A condition that is evaluated against each value in the array. Only the array elements where the condition returns `true` are preserved.",
        "schema": {
          "type": "object",
          "subtype": "process-graph",
          "parameters": [
            {
              "name": "x",
              "description": "The value of the current element being processed.",
              "schema": {
                "description": "Any data type."
              }
            },
            {
              "name": "index",
              "description": "The zero-based index of the current element being processed.",
              "schema": {
                "type": "integer"
              }
            },
            {
              "name": "label",
              "description": "The label of the current element being processed. Only populated for labeled arrays.",
              "schema": [
                {
                  "type": "number"
                },
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "optional": true
            },
            {
              "name": "context",
              "description": "Additional data passed by the user.",
              "schema": {
                "description": "Any data type."
              },
              "optional": true,
              "default": null
            }
          ]
        }
      },
      {
        "name": "context",
        "description": "Additional data to be passed to the condition.",
        "schema": {
          "description": "Any data type."
        },
        "optional": true,
        "default": null
      }
    ],
    "returns": {
      "description": "An array filtered by the specified condition. The number of elements are less than or equal compared to the original array.",
      "schema": {
        "type": "array",
        "items": {
          "description": "Any data type is allowed."
        }
      }
    }
  },
  {
    "id": "array_find",
    "summary": "Get the index for a value in an array",
    "description": "Checks whether the array specified for `data` contains the value specified in `value` and returns the zero-based index for the first match. If there's no match, `null` is returned.\n\n**Remarks:**\n\n* To get a boolean value returned use ``array_contains()``.\n* All definitions for the process ``eq()`` regarding the comparison of values apply here as well. A `null` return value from ``eq()`` is handled exactly as `false` (no match).\n* Data types MUST be checked strictly, for example a string with the content *1* is not equal to the number *1*.\n* An integer *1* is equal to a floating point number *1.0* as `integer` is a sub-type of `number`. Still, this process may return unexpectedly `false` when comparing floating point numbers due to floating point inaccuracy in machine-based computation.\n* Temporal strings are treated as normal strings and MUST NOT be interpreted.\n* If the specified value is an array, object or null, the process always returns `null`. See the examples for one to find `null` values.",
    "categories": [
      "arrays"
    ],
    "parameters": [
      {
        "name": "data",
        "description": "List to find the value in.",
        "schema": {
          "type": "array",
          "items": {
            "description": "Any data type is allowed."
          }
        }
      },
      {
        "name": "value",
        "description": "Value to find in `data`.",
        "schema": {
          "description": "Any data type is allowed."
        }
      }
    ],
    "returns": {
      "description": "Returns the index of the first element with the specified value. If no element was found, `null` is returned.",
      "schema": [
        {
          "type": "null"
        },
        {
          "type": "integer",
          "minimum": 0
        }
      ]
    },
    "examples": [
      {
        "title": "Find `null` values",
        "description": "Get the index of the first `null` value in an array.",
        "process_graph": {
          "apply": {
            "process_id": "array_apply",
            "arguments": {
              "data": {
                "from_parameter": "data"
              },
              "process": {
                "process-graph": {
                  "is_null": {
                    "process_id": "is_nodata",
                    "arguments": {
                      "from_parameter": "x"
                    },
                    "result": true
                  }
                }
              }
            }
          },
          "find": {
            "process_id": "array_find",
            "arguments": {
              "data": {
                "from_node": "apply"
              },
              "value": true
            },
            "result": true
          }
        }
      },
      {
        "arguments": {
          "data": [
            1,
            2,
            3
          ],
          "value": 2
        },
        "returns": 1
      },
      {
        "arguments": {
          "data": [
            "A",
            "B",
            "C"
          ],
          "value": "b"
        },
        "returns": null
      },
      {
        "arguments": {
          "data": [
            1,
            2,
            3
          ],
          "value": "2"
        },
        "returns": null
      },
      {
        "arguments": {
          "data": [
            1,
            null,
            2,
            null
          ],
          "value": null
        },
        "returns": 1
      },
      {
        "arguments": {
          "data": [
            [
              1,
              2
            ],
            [
              3,
              4
            ]
          ],
          "value": [
            1,
            2
          ]
        },
        "returns": null
      },
      {
        "arguments": {
          "data": [
            [
              1,
              2
            ],
            [
              3,
              4
            ]
          ],
          "value": 2
        },
        "returns": null
      },
      {
        "arguments": {
          "data": [
            {
              "a": "b"
            },
            {
              "c": "d"
            }
          ],
          "value": {
            "a": "b"
          }
        },
        "returns": null
      }
    ]
  },
  {
    "id": "array_labels",
    "summary": "Get the labels for an array",
    "description": "Returns all labels for a labeled array in the data cube. The labels have the same order as in the array.",
    "categories": [
      "arrays"
    ],
    "parameters": [
      {
        "name": "data",
        "description": "An array with labels.",
        "schema": {
          "type": "array",
          "subtype": "labeled-array"
        }
      }
    ],
    "returns": {
      "description": "The labels as array.",
      "schema": {
        "type": "array",
        "items": {
          "anyOf": [
            {
              "type": "number"
            },
            {
              "type": "string"
            }
          ]
        }
      }
    }
  },
  {
    "id": "arsinh",
    "summary": "Inverse hyperbolic sine",
    "description": "Computes the inverse hyperbolic sine of `x`. It is the inverse function of the hyperbolic sine so that *arsinh(sinh(x)) = x*.\n\nWorks on radians only.\nThe no-data value `null` is passed through and therefore gets propagated.",
    "categories": [
      "math > trigonometric"
    ],
    "parameters": [
      {
        "name": "x",
        "description": "A number.",
        "schema": {
          "type": [
            "number",
            "null"
          ]
        }
      }
    ],
    "returns": {
      "description": "The computed angle in radians.",
      "schema": {
        "type": [
          "number",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "x": 0
        },
        "returns": 0
      },
      {
        "process_graph": {
          "sinh1": {
            "process_id": "sinh",
            "arguments": {
              "x": 0.5
            }
          },
          "arcsinh1": {
            "process_id": "arsinh",
            "arguments": {
              "x": {
                "from_node": "sinh1"
              }
            },
            "result": true
          }
        },
        "returns": 0.5
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "http://mathworld.wolfram.com/InverseHyperbolicSine.html",
        "title": "Inverse hyperbolic sine explained by Wolfram MathWorld"
      }
    ]
  },
  {
    "id": "artanh",
    "summary": "Inverse hyperbolic tangent",
    "description": "Computes the inverse hyperbolic tangent of `x`. It is the inverse function of the hyperbolic tangent so that *artanh(tanh(x)) = x*.\n\nWorks on radians only.\nThe no-data value `null` is passed through and therefore gets propagated.",
    "categories": [
      "math > trigonometric"
    ],
    "parameters": [
      {
        "name": "x",
        "description": "A number.",
        "schema": {
          "type": [
            "number",
            "null"
          ]
        }
      }
    ],
    "returns": {
      "description": "The computed angle in radians.",
      "schema": {
        "type": [
          "number",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "x": 0
        },
        "returns": 0
      },
      {
        "process_graph": {
          "cosh1": {
            "process_id": "tanh",
            "arguments": {
              "x": 0.5
            }
          },
          "arctanh1": {
            "process_id": "artanh",
            "arguments": {
              "x": {
                "from_node": "tanh1"
              }
            },
            "result": true
          }
        },
        "returns": 0.5
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "http://mathworld.wolfram.com/InverseHyperbolicTangent.html",
        "title": "Inverse hyperbolic tangent explained by Wolfram MathWorld"
      }
    ]
  },
  {
    "id": "between",
    "summary": "Between comparison",
    "description": "By default this process checks whether `x` is greater than or equal to `min` and lower than or equal to `max`, which is the same as computing `and(gte(x, min), lte(x, max))`. Therefore, all definitions from ``and()``, ``gte()`` and ``lte()`` apply here as well.\n\nIf `exclude_max` is set to `true` the upper bound is excluded so that the process checks whether `x` is greater than or equal to `min` and lower than `max`. In this case the process works the same as computing `and(gte(x, min), lt(x, max))`.\n\nLower and upper bounds are not allowed to be swapped. So `min` MUST be lower than or equal to `max` or otherwise the process always returns `false`.",
    "categories": [
      "comparison"
    ],
    "parameters": [
      {
        "name": "x",
        "description": "The value to check.",
        "schema": {
          "description": "Any data type is allowed."
        }
      },
      {
        "name": "min",
        "description": "Lower boundary (inclusive) to check against.",
        "schema": [
          {
            "type": "number"
          },
          {
            "type": "string",
            "format": "date-time",
            "subtype": "date-time"
          },
          {
            "type": "string",
            "format": "date",
            "subtype": "date"
          },
          {
            "type": "string",
            "format": "time",
            "subtype": "time"
          }
        ]
      },
      {
        "name": "max",
        "description": "Upper boundary (inclusive) to check against.",
        "schema": [
          {
            "type": "number"
          },
          {
            "type": "string",
            "format": "date-time",
            "subtype": "date-time"
          },
          {
            "type": "string",
            "format": "date",
            "subtype": "date"
          },
          {
            "type": "string",
            "format": "time",
            "subtype": "time"
          }
        ]
      },
      {
        "name": "exclude_max",
        "description": "Exclude the upper boundary `max` if set to `true`. Defaults to `false`.",
        "schema": {
          "type": "boolean"
        },
        "default": false,
        "optional": true
      }
    ],
    "returns": {
      "description": "`true` if `x` is between the specified bounds, otherwise `false`.",
      "schema": {
        "type": [
          "boolean",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "x": null,
          "min": 0,
          "max": 1
        },
        "returns": null
      },
      {
        "arguments": {
          "x": 1,
          "min": 0,
          "max": 1
        },
        "returns": true
      },
      {
        "arguments": {
          "x": 1,
          "min": 0,
          "max": 1,
          "exclude_max": true
        },
        "returns": false
      },
      {
        "description": "Swapped bounds (min is greater than max) MUST always return `false`.",
        "arguments": {
          "x": 0.5,
          "min": 1,
          "max": 0
        },
        "returns": false
      },
      {
        "arguments": {
          "x": -0.5,
          "min": -1,
          "max": 0
        },
        "returns": true
      },
      {
        "arguments": {
          "x": "00:59:59Z",
          "min": "01:00:00+01:00",
          "max": "01:00:00Z"
        },
        "returns": true
      },
      {
        "arguments": {
          "x": "2018-07-23T17:22:45Z",
          "min": "2018-01-01T00:00:00Z",
          "max": "2018-12-31T23:59:59Z"
        },
        "returns": true
      },
      {
        "arguments": {
          "x": "2000-01-01",
          "min": "2018-01-01",
          "max": "2020-01-01"
        },
        "returns": false
      },
      {
        "arguments": {
          "x": "2018-12-31T17:22:45Z",
          "min": "2018-01-01",
          "max": "2018-12-31"
        },
        "returns": true
      },
      {
        "arguments": {
          "x": "2018-12-31T17:22:45Z",
          "min": "2018-01-01",
          "max": "2018-12-31",
          "exclude_max": true
        },
        "returns": false
      }
    ],
    "process_graph": {
      "gte": {
        "process_id": "gte",
        "arguments": {
          "x": {
            "from_parameter": "x"
          },
          "y": {
            "from_parameter": "min"
          }
        }
      },
      "lte": {
        "process_id": "lte",
        "arguments": {
          "x": {
            "from_parameter": "x"
          },
          "y": {
            "from_parameter": "max"
          }
        }
      },
      "lt": {
        "process_id": "lt",
        "arguments": {
          "x": {
            "from_parameter": "x"
          },
          "y": {
            "from_parameter": "max"
          }
        }
      },
      "if": {
        "process_id": "if",
        "arguments": {
          "value": {
            "from_parameter": "exclude_max"
          },
          "accept": {
            "from_node": "lte"
          },
          "reject": {
            "from_node": "lt"
          }
        }
      },
      "and": {
        "process_id": "and",
        "arguments": {
          "x": {
            "from_node": "gte"
          },
          "y": {
            "from_node": "if"
          }
        },
        "result": true
      }
    }
  },
  {
    "id": "ceil",
    "summary": "Round fractions up",
    "description": "The least integer greater than or equal to the number `x`.\n\nThe no-data value `null` is passed through and therefore gets propagated.",
    "categories": [
      "math > rounding"
    ],
    "parameters": [
      {
        "name": "x",
        "description": "A number to round up.",
        "schema": {
          "type": [
            "number",
            "null"
          ]
        }
      }
    ],
    "returns": {
      "description": "The number rounded up.",
      "schema": {
        "type": [
          "integer",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "x": 0
        },
        "returns": 0
      },
      {
        "arguments": {
          "x": 3.5
        },
        "returns": 4
      },
      {
        "arguments": {
          "x": -0.4
        },
        "returns": 0
      },
      {
        "arguments": {
          "x": -3.5
        },
        "returns": -3
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "http://mathworld.wolfram.com/CeilingFunction.html",
        "title": "Ceiling explained by Wolfram MathWorld"
      }
    ]
  },
  {
    "id": "climatological_normal",
    "summary": "Computes climatology normals",
    "description": "Climatological normal period is a usually 30 year average of a weather variable. Climatological normals are used as an average or baseline to evaluate climate events and provide context for yearly, monthly, daily or seasonal variability. The default climatology period is from 1981 until 2010 (both inclusive).",
    "categories": [
      "climatology"
    ],
    "parameters": [
      {
        "name": "data",
        "description": "A data cube with exactly one temporal dimension. The data cube must span at least the temporal interval specified in the parameter `climatology-period`.\n\nSeasonal periods may span two consecutive years, e.g. temporal winter that includes months December, January and February. If the required months before the actual climate period are available, the season is taken into account. If not available, the first season is not taken into account and the seasonal mean is based on one year less than the other seasonal normals. The incomplete season at the end of the last year is never taken into account.",
        "schema": {
          "type": "object",
          "subtype": "raster-cube"
        }
      },
      {
        "name": "period",
        "description": "The time intervals to aggregate the average value for. The following pre-defined frequencies are supported:\n\n* `day`: Day of the year\n* `month`: Month of the year\n* `climatology-period`: The period specified in the `climatology-period`.\n* `season`: Refers to three month periods of the calendar seasons (December - February, March - May, June - August, September - November).\n* `tropical-season`: Refers to the six month periods of the tropical seasons (November - April, May - October).",
        "schema": {
          "type": "string",
          "enum": [
            "day",
            "month",
            "season",
            "tropical-season",
            "climatology-period"
          ]
        }
      },
      {
        "name": "climatology_period",
        "description": "The climatology period as closed temporal interval. The first element of the array is the first year to be fully included in the temporal interval. The second element is the last year to be fully included in the temporal interval. The default period is from 1981 until 2010 (both inclusive).",
        "schema": {
          "type": "array",
          "subtype": "temporal-interval",
          "minItems": 2,
          "maxItems": 2,
          "items": {
            "type": "string",
            "subtype": "year",
            "minLength": 4,
            "maxLength": 4,
            "pattern": "^\\d{4}$"
          }
        },
        "default": [
          "1981",
          "2010"
        ],
        "optional": true
      }
    ],
    "returns": {
      "description": "A data cube with potentially cardinality, but the same resolution and number of dimensions as the original data cube. The temporal dimension has the following dimension labels:\n\n* `day`: `001` - `365`\n* `month`: `01` - `12`\n* `climatology-period`: `climatology-period`\n* `season`: `djf` (December - February), `mam` (March - May), `jja` (June - August), `son` (September - November)\n* `tropical-season`: `ndjfma` (November - April), `mjjaso` (May - October)",
      "schema": {
        "type": "object",
        "subtype": "raster-cube"
      }
    },
    "links": [
      {
        "rel": "about",
        "href": "https://en.wikipedia.org/wiki/Climatological_normal",
        "title": "Background information on climatology normal by Wikipedia"
      }
    ]
  },
  {
    "id": "clip",
    "summary": "Clip a value between a minimum and a maximum",
    "description": "Clips a number between specified minimum and maximum values. A value larger than the maximal value will have the maximal value, a value lower than minimal value will have the minimal value.\n\nThe no-data value `null` is passed through and therefore gets propagated.",
    "categories": [
      "math"
    ],
    "parameters": [
      {
        "name": "x",
        "description": "A number.",
        "schema": {
          "type": [
            "number",
            "null"
          ]
        }
      },
      {
        "name": "min",
        "description": "Minimum value. If the value is lower than this value, the process will return the value of this parameter.",
        "schema": {
          "type": "number"
        }
      },
      {
        "name": "max",
        "description": "Maximum value. If the value is greater than this value, the process will return the value of this parameter.",
        "schema": {
          "type": "number"
        }
      }
    ],
    "returns": {
      "description": "The value clipped to the specified range.",
      "schema": {
        "type": [
          "number",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "x": -5,
          "min": -1,
          "max": 1
        },
        "returns": -1
      },
      {
        "arguments": {
          "x": 10.001,
          "min": 1,
          "max": 10
        },
        "returns": 10
      },
      {
        "arguments": {
          "x": 0.000001,
          "min": 0,
          "max": 0.02
        },
        "returns": 0.000001
      },
      {
        "arguments": {
          "x": null,
          "min": 0,
          "max": 1
        },
        "returns": null
      }
    ],
    "process_graph": {
      "min": {
        "process_id": "min",
        "arguments": {
          "data": [
            {
              "from_parameter": "max"
            },
            {
              "from_parameter": "x"
            }
          ]
        }
      },
      "max": {
        "process_id": "max",
        "arguments": {
          "data": [
            {
              "from_parameter": "min"
            },
            {
              "from_node": "min"
            }
          ]
        },
        "result": true
      }
    }
  },
  {
    "id": "cos",
    "summary": "Cosine",
    "description": "Computes the cosine of `x`.\n\nWorks on radians only.\nThe no-data value `null` is passed through and therefore gets propagated.",
    "categories": [
      "math > trigonometric"
    ],
    "parameters": [
      {
        "name": "x",
        "description": "An angle in radians.",
        "schema": {
          "type": [
            "number",
            "null"
          ]
        }
      }
    ],
    "returns": {
      "description": "The computed cosine of `x`.",
      "schema": {
        "type": [
          "number",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "x": 0
        },
        "returns": 1
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "http://mathworld.wolfram.com/Cosine.html",
        "title": "Cosine explained by Wolfram MathWorld"
      }
    ]
  },
  {
    "id": "cosh",
    "summary": "Hyperbolic cosine",
    "description": "Computes the hyperbolic cosine of `x`.\n\nWorks on radians only.\nThe no-data value `null` is passed through and therefore gets propagated.",
    "categories": [
      "math > trigonometric"
    ],
    "parameters": [
      {
        "name": "x",
        "description": "An angle in radians.",
        "schema": {
          "type": [
            "number",
            "null"
          ]
        }
      }
    ],
    "returns": {
      "description": "The computed hyperbolic cosine of `x`.",
      "schema": {
        "type": [
          "number",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "x": 0
        },
        "returns": 1
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "http://mathworld.wolfram.com/HyperbolicCosine.html",
        "title": "Hyperbolic cosine explained by Wolfram MathWorld"
      }
    ]
  },
  {
    "id": "count",
    "summary": "Count the number of elements",
    "description": "Gives the number of elements in an array that matches the specified condition.\n\n**Remarks:**\n\n* Counts the number of valid elements by default (`condition` is set to `null`). A valid element is every element for which ``is_valid()`` returns `true`.\n* To count all elements in a list set the `condition` parameter to boolean `true`.",
    "categories": [
      "arrays",
      "reducer"
    ],
    "parameters": [
      {
        "name": "data",
        "description": "An array with elements of any data type.",
        "schema": {
          "type": "array",
          "items": {
            "description": "Any data type is allowed."
          }
        }
      },
      {
        "name": "condition",
        "description": "A condition consists of one ore more processes, which in the end return a boolean value. It is evaluated against each element in the array. An element is counted only if the condition returns `true`. Defaults to count valid elements in a list (see ``is_valid()``). Setting this parameter to boolean `true` counts all elements in the list.",
        "schema": [
          {
            "title": "Condition",
            "description": "A logical expression that is evaluated against each element in the array.",
            "type": "object",
            "subtype": "process-graph",
            "parameters": [
              {
                "name": "x",
                "description": "The value of the current element being processed.",
                "schema": {
                  "description": "Any data type."
                }
              },
              {
                "name": "context",
                "description": "Additional data passed by the user.",
                "schema": {
                  "description": "Any data type."
                },
                "optional": true,
                "default": null
              }
            ]
          },
          {
            "title": "All elements",
            "description": "Boolean `true` counts all elements in the list.",
            "type": "boolean",
            "const": true
          },
          {
            "title": "Valid elements",
            "description": "`null` counts valid elements in the list.",
            "type": "null"
          }
        ],
        "default": null,
        "optional": true
      },
      {
        "name": "context",
        "description": "Additional data to be passed to the condition.",
        "schema": {
          "description": "Any data type."
        },
        "optional": true,
        "default": null
      }
    ],
    "returns": {
      "description": "The counted number of elements.",
      "schema": {
        "type": "number"
      }
    },
    "examples": [
      {
        "arguments": {
          "data": []
        },
        "returns": 0
      },
      {
        "arguments": {
          "data": [
            1,
            0,
            3,
            2
          ]
        },
        "returns": 4
      },
      {
        "arguments": {
          "data": [
            "ABC",
            null
          ]
        },
        "returns": 1
      },
      {
        "arguments": {
          "data": [
            false,
            null
          ],
          "condition": true
        },
        "returns": 2
      },
      {
        "arguments": {
          "data": [
            0,
            1,
            2,
            3,
            4,
            5,
            null
          ],
          "condition": {
            "gt": {
              "process_id": "gt",
              "arguments": {
                "x": {
                  "from_parameter": "element"
                },
                "y": 2
              },
              "result": true
            }
          }
        },
        "returns": 3
      }
    ]
  },
  {
    "id": "create_raster_cube",
    "summary": "Create an empty raster data cube",
    "description": "Creates a new raster data cube without dimensions. Dimensions can be added with ``add_dimension()``.",
    "categories": [
      "cubes"
    ],
    "parameters": [],
    "returns": {
      "description": "An empty raster data cube.",
      "schema": {
        "type": "object",
        "subtype": "raster-cube"
      }
    }
  },
  {
    "id": "cummax",
    "summary": "Cumulative maxima",
    "description": "Finds cumulative maxima of an array of numbers. Every computed element is equal to the bigger one between current element and the previously computed element. The returned array and the input array have always the same length.\n\nBy default, no-data values are skipped, but stay in the result. Setting the `ignore_nodata` flag to `true` makes that once a no-data value / `null` is reached all following elements are set to `null` in the result.",
    "categories": [
      "math > cumulative"
    ],
    "parameters": [
      {
        "name": "data",
        "description": "An array of numbers.",
        "schema": {
          "type": "array",
          "items": {
            "type": [
              "number",
              "null"
            ]
          }
        }
      },
      {
        "name": "ignore_nodata",
        "description": "Indicates whether no-data values are ignored or not. Ignores them by default. Setting this flag to `false` considers no-data values so that `null` is set for all the following elements.",
        "schema": {
          "type": "boolean"
        },
        "default": true,
        "optional": true
      }
    ],
    "returns": {
      "description": "An array with the computed cumulative maxima.",
      "schema": {
        "type": "array",
        "items": {
          "type": [
            "number",
            "null"
          ]
        }
      }
    },
    "examples": [
      {
        "arguments": {
          "data": [
            1,
            3,
            5,
            3,
            1
          ]
        },
        "returns": [
          1,
          3,
          5,
          5,
          5
        ]
      },
      {
        "arguments": {
          "data": [
            1,
            3,
            null,
            5,
            1
          ]
        },
        "returns": [
          1,
          3,
          null,
          5,
          5
        ]
      },
      {
        "arguments": {
          "data": [
            1,
            3,
            null,
            5,
            1
          ],
          "ignore_nodata": false
        },
        "returns": [
          1,
          3,
          null,
          null,
          null
        ]
      }
    ]
  },
  {
    "id": "cummin",
    "summary": "Cumulative minima",
    "description": "Finds cumulative minima of an array of numbers. Every computed element is equal to the smaller one between current element and the previously computed element. The returned array and the input array have always the same length.\n\nBy default, no-data values are skipped, but stay in the result. Setting the `ignore_nodata` flag to `true` makes that once a no-data value / `null` is reached all following elements are set to `null` in the result.",
    "categories": [
      "math > cumulative"
    ],
    "parameters": [
      {
        "name": "data",
        "description": "An array of numbers.",
        "schema": {
          "type": "array",
          "items": {
            "type": [
              "number",
              "null"
            ]
          }
        }
      },
      {
        "name": "ignore_nodata",
        "description": "Indicates whether no-data values are ignored or not. Ignores them by default. Setting this flag to `false` considers no-data values so that `null` is set for all the following elements.",
        "schema": {
          "type": "boolean"
        },
        "default": true,
        "optional": true
      }
    ],
    "returns": {
      "description": "An array with the computed cumulative minima.",
      "schema": {
        "type": "array",
        "items": {
          "type": [
            "number",
            "null"
          ]
        }
      }
    },
    "examples": [
      {
        "arguments": {
          "data": [
            5,
            3,
            1,
            3,
            5
          ]
        },
        "returns": [
          5,
          3,
          1,
          1,
          1
        ]
      },
      {
        "arguments": {
          "data": [
            5,
            3,
            null,
            1,
            5
          ]
        },
        "returns": [
          5,
          3,
          null,
          1,
          1
        ]
      },
      {
        "arguments": {
          "data": [
            5,
            3,
            null,
            1,
            5
          ],
          "ignore_nodata": false
        },
        "returns": [
          5,
          3,
          null,
          null,
          null
        ]
      }
    ]
  },
  {
    "id": "cumproduct",
    "summary": "Cumulative products",
    "description": "Computes cumulative products of an array of numbers. Every computed element is equal to the product of current and all previous values. The returned array and the input array have always the same length.\n\nBy default, no-data values are skipped, but stay in the result. Setting the `ignore_nodata` flag to `true` makes that once a no-data value / `null` is reached all following elements are set to `null` in the result.",
    "categories": [
      "math > cumulative"
    ],
    "parameters": [
      {
        "name": "data",
        "description": "An array of numbers.",
        "schema": {
          "type": "array",
          "items": {
            "type": [
              "number",
              "null"
            ]
          }
        }
      },
      {
        "name": "ignore_nodata",
        "description": "Indicates whether no-data values are ignored or not. Ignores them by default. Setting this flag to `false` considers no-data values so that `null` is set for all the following elements.",
        "schema": {
          "type": "boolean"
        },
        "default": true,
        "optional": true
      }
    ],
    "returns": {
      "description": "An array with the computed cumulative products.",
      "schema": {
        "type": "array",
        "items": {
          "type": [
            "number",
            "null"
          ]
        }
      }
    },
    "examples": [
      {
        "arguments": {
          "data": [
            1,
            3,
            5,
            3,
            1
          ]
        },
        "returns": [
          1,
          3,
          15,
          45,
          45
        ]
      },
      {
        "arguments": {
          "data": [
            1,
            2,
            3,
            null,
            3,
            1
          ]
        },
        "returns": [
          1,
          2,
          6,
          null,
          18,
          18
        ]
      },
      {
        "arguments": {
          "data": [
            1,
            2,
            3,
            null,
            3,
            1
          ],
          "ignore_nodata": false
        },
        "returns": [
          1,
          2,
          6,
          null,
          null,
          null
        ]
      }
    ]
  },
  {
    "id": "cumsum",
    "summary": "Cumulative sums",
    "description": "Computes cumulative sums of an array of numbers. Every computed element is equal to the sum of current and all previous values. The returned array and the input array have always the same length.\n\nBy default, no-data values are skipped, but stay in the result. Setting the `ignore_nodata` flag to `true` makes that once a no-data value / `null` is reached all following elements are set to `null` in the result.",
    "categories": [
      "math > cumulative"
    ],
    "parameters": [
      {
        "name": "data",
        "description": "An array of numbers.",
        "schema": {
          "type": "array",
          "items": {
            "type": [
              "number",
              "null"
            ]
          }
        }
      },
      {
        "name": "ignore_nodata",
        "description": "Indicates whether no-data values are ignored or not. Ignores them by default. Setting this flag to `false` considers no-data values so that `null` is set for all the following elements.",
        "schema": {
          "type": "boolean"
        },
        "default": true,
        "optional": true
      }
    ],
    "returns": {
      "description": "An array with the computed cumulative sums.",
      "schema": {
        "type": "array",
        "items": {
          "type": [
            "number",
            "null"
          ]
        }
      }
    },
    "examples": [
      {
        "arguments": {
          "data": [
            1,
            3,
            5,
            3,
            1
          ]
        },
        "returns": [
          1,
          4,
          9,
          12,
          13
        ]
      },
      {
        "arguments": {
          "data": [
            1,
            3,
            null,
            3,
            1
          ]
        },
        "returns": [
          1,
          4,
          null,
          7,
          8
        ]
      },
      {
        "arguments": {
          "data": [
            1,
            3,
            null,
            3,
            1
          ],
          "ignore_nodata": false
        },
        "returns": [
          1,
          4,
          null,
          null,
          null
        ]
      }
    ]
  },
  {
    "id": "debug",
    "summary": "Publish debugging information",
    "description": "Sends debugging information about the data to the log output. Passes the data through.",
    "categories": [
      "development"
    ],
    "parameters": [
      {
        "name": "data",
        "description": "Data to publish.",
        "schema": {
          "description": "Any data type is allowed."
        }
      },
      {
        "name": "code",
        "description": "An identifier to help identify the log entry in a bunch of other log entries.",
        "schema": {
          "type": "string"
        },
        "default": "",
        "optional": true
      },
      {
        "name": "level",
        "description": "The severity level of this message, defaults to `info`. Note that the level `error` forces the computation to be stopped!",
        "schema": {
          "type": "string",
          "enum": [
            "error",
            "warning",
            "info",
            "debug"
          ]
        },
        "default": "info",
        "optional": true
      },
      {
        "name": "message",
        "description": "A message to send in addition to the data.",
        "schema": {
          "type": "string"
        },
        "default": "",
        "optional": true
      }
    ],
    "returns": {
      "description": "Returns the data as passed to the `data` parameter.",
      "schema": {
        "description": "Any data type is allowed."
      }
    }
  },
  {
    "id": "dimension_labels",
    "summary": "Get the dimension labels",
    "description": "Returns all labels for a dimension in the data cube. The labels have the same order as in the data cube.",
    "categories": [
      "cubes"
    ],
    "parameters": [
      {
        "name": "data",
        "description": "The data cube.",
        "schema": {
          "type": "object",
          "subtype": "raster-cube"
        }
      },
      {
        "name": "dimension",
        "description": "The name of the dimension to get the labels for.",
        "schema": {
          "type": "string"
        }
      }
    ],
    "returns": {
      "description": "The labels as array.",
      "schema": {
        "type": "array",
        "items": {
          "anyOf": [
            {
              "type": "number"
            },
            {
              "type": "string"
            }
          ]
        }
      }
    }
  },
  {
    "id": "divide",
    "summary": "Division of two numbers",
    "description": "Divides argument `x` by the argument `y` (*x / y*) and returns the computed result.\n\nNo-data values are taken into account so that `null` is returned if any element is such a value.\n\nThe computations follow [IEEE Standard 754](https://ieeexplore.ieee.org/document/8766229) whenever the processing environment supports it. Therefore, a division by zero results in infinity if the processing environment supports it. Otherwise a `DivisionByZero` error must the thrown.",
    "categories": [
      "math"
    ],
    "parameters": [
      {
        "name": "x",
        "description": "The dividend.",
        "schema": {
          "type": [
            "number",
            "null"
          ]
        }
      },
      {
        "name": "y",
        "description": "The divisor.",
        "schema": {
          "type": [
            "number",
            "null"
          ]
        }
      }
    ],
    "returns": {
      "description": "The computed result.",
      "schema": {
        "type": [
          "number",
          "null"
        ]
      }
    },
    "exceptions": {
      "DivisionByZero": {
        "message": "Division by zero is not supported."
      }
    },
    "examples": [
      {
        "arguments": {
          "x": 5,
          "y": 2.5
        },
        "returns": 2
      },
      {
        "arguments": {
          "x": -2,
          "y": 4
        },
        "returns": -0.5
      },
      {
        "arguments": {
          "x": 1,
          "y": null
        },
        "returns": null
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "http://mathworld.wolfram.com/Division.html",
        "title": "Division explained by Wolfram MathWorld"
      },
      {
        "rel": "about",
        "href": "https://ieeexplore.ieee.org/document/8766229",
        "title": "IEEE Standard 754-2019 for Floating-Point Arithmetic"
      }
    ]
  },
  {
    "id": "drop_dimension",
    "summary": "Remove a dimension",
    "description": "Drops a dimension from the data cube.\n\nDropping a dimension only works on dimensions with a single dimension label left, otherwise the process fails with a `DimensionLabelCountMismatch` error. Dimension values can be reduced to a single value with a filter such as ``filter_bands()`` or the ``reduce_dimension()`` process. If a dimension with the specified name does not exist, the process fails with a `DimensionNotAvailable` error.",
    "categories": [
      "cubes"
    ],
    "parameters": [
      {
        "name": "data",
        "description": "The data cube to drop a dimension from.",
        "schema": {
          "type": "object",
          "subtype": "raster-cube"
        }
      },
      {
        "name": "name",
        "description": "Name of the dimension to drop.",
        "schema": {
          "type": "string"
        }
      }
    ],
    "returns": {
      "description": "The data cube with one dimension less.",
      "schema": {
        "type": "object",
        "subtype": "raster-cube"
      }
    },
    "exceptions": {
      "DimensionLabelCountMismatch": {
        "message": "The number of dimension labels exceeds one, which requires a reducer."
      },
      "DimensionNotAvailable": {
        "message": "A dimension with the specified name does not exist."
      }
    }
  },
  {
    "id": "e",
    "summary": "Euler's number (e)",
    "description": "The real number *e* is a mathematical constant that is the base of the natural logarithm such that *ln(e) = 1*. The numerical value is approximately *2.71828*.",
    "categories": [
      "math > constants",
      "math > exponential & logarithmic"
    ],
    "parameters": [],
    "returns": {
      "description": "The numerical value of Euler's number.",
      "schema": {
        "type": "number"
      }
    },
    "examples": [
      {
        "title": "Test for ln(e) = 1",
        "process_graph": {
          "e1": {
            "process_id": "e",
            "arguments": {}
          },
          "ln1": {
            "process_id": "ln",
            "arguments": {
              "data": {
                "from_node": "e1"
              }
            },
            "result": true
          }
        },
        "returns": 1
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "http://mathworld.wolfram.com/e.html",
        "title": "Mathematical constant e explained by Wolfram MathWorld"
      }
    ]
  },
  {
    "id": "eq",
    "summary": "Equal to comparison",
    "description": "Compares whether `x` is strictly equal to `y`.\n\n**Remarks:**\n\n* Data types MUST be checked strictly, for example a string with the content *1* is not equal to the number *1*. Nevertheless, an integer *1* is equal to a floating point number *1.0* as `integer` is a sub-type of `number`.\n* If any operand is `null`, the return value is `null`. Therefore, `eq(null, null)` returns `null` instead of `true`.\n* If any operand is an array or object, the return value is `false`.\n* Strings are expected to be encoded in UTF-8 by default.\n* Temporal strings MUST be compared differently than other strings and MUST NOT be compared based on their string representation due to different possible representations. For example, the UTC time zone representation `Z` has the same meaning as `+00:00`.",
    "categories": [
      "texts",
      "comparison"
    ],
    "parameters": [
      {
        "name": "x",
        "description": "First operand.",
        "schema": {
          "description": "Any data type is allowed."
        }
      },
      {
        "name": "y",
        "description": "Second operand.",
        "schema": {
          "description": "Any data type is allowed."
        }
      },
      {
        "name": "delta",
        "description": "Only applicable for comparing two numbers. If this optional parameter is set to a positive non-zero number the equality of two numbers is checked against a delta value. This is especially useful to circumvent problems with floating point inaccuracy in machine-based computation.\n\nThis option is basically an alias for the following computation: `lte(abs(minus([x, y]), delta)`",
        "schema": {
          "type": [
            "number",
            "null"
          ]
        },
        "default": null,
        "optional": true
      },
      {
        "name": "case_sensitive",
        "description": "Only applicable for comparing two strings. Case sensitive comparison can be disabled by setting this parameter to `false`.",
        "schema": {
          "type": "boolean"
        },
        "default": true,
        "optional": true
      }
    ],
    "returns": {
      "description": "Returns `true` if `x` is equal to `y`, `null` if any operand is `null`, otherwise `false`.",
      "schema": {
        "type": [
          "boolean",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "x": 1,
          "y": null
        },
        "returns": null
      },
      {
        "arguments": {
          "x": null,
          "y": null
        },
        "returns": null
      },
      {
        "arguments": {
          "x": 1,
          "y": 1
        },
        "returns": true
      },
      {
        "arguments": {
          "x": 1,
          "y": "1"
        },
        "returns": false
      },
      {
        "arguments": {
          "x": 0,
          "y": false
        },
        "returns": false
      },
      {
        "arguments": {
          "x": 1.02,
          "y": 1,
          "delta": 0.01
        },
        "returns": false
      },
      {
        "arguments": {
          "x": -1,
          "y": -1.001,
          "delta": 0.01
        },
        "returns": true
      },
      {
        "arguments": {
          "x": 115,
          "y": 110,
          "delta": 10
        },
        "returns": true
      },
      {
        "arguments": {
          "x": "Test",
          "y": "test"
        },
        "returns": false
      },
      {
        "arguments": {
          "x": "Test",
          "y": "test",
          "case_sensitive": false
        },
        "returns": true
      },
      {
        "arguments": {
          "x": "",
          "y": "",
          "case_sensitive": false
        },
        "returns": true
      },
      {
        "arguments": {
          "x": "00:00:00+00:00",
          "y": "00:00:00Z"
        },
        "returns": true
      },
      {
        "description": "`y` is not a valid date-time representation and therefore will be treated as a string so that the provided values are not equal.",
        "arguments": {
          "x": "2018-01-01T12:00:00Z",
          "y": "2018-01-01T12:00:00"
        },
        "returns": false
      },
      {
        "description": "01:00 in the time zone +1 is equal to 00:00 in UTC.",
        "arguments": {
          "x": "2018-01-01T00:00:00Z",
          "y": "2018-01-01T01:00:00+01:00"
        },
        "returns": true
      },
      {
        "arguments": {
          "x": [
            1,
            2,
            3
          ],
          "y": [
            1,
            2,
            3
          ]
        },
        "returns": false
      }
    ]
  },
  {
    "id": "exp",
    "summary": "Exponentiation to the base e",
    "description": "Exponential function to the base *e* raised to the power of `p`.\n\nThe no-data value `null` is passed through and therefore gets propagated.",
    "categories": [
      "math > exponential & logarithmic"
    ],
    "parameters": [
      {
        "name": "p",
        "description": "The numerical exponent.",
        "schema": {
          "type": [
            "number",
            "null"
          ]
        }
      }
    ],
    "returns": {
      "description": "The computed value for *e* raised to the power of `p`.",
      "schema": {
        "type": [
          "number",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "p": 0
        },
        "returns": 1
      },
      {
        "arguments": {
          "p": null
        },
        "returns": null
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "http://mathworld.wolfram.com/ExponentialFunction.html",
        "title": "Exponential function explained by Wolfram MathWorld"
      }
    ],
    "process_graph": {
      "e": {
        "process_id": "e",
        "arguments": {}
      },
      "power": {
        "process_id": "power",
        "arguments": {
          "base": {
            "from_node": "e"
          },
          "p": {
            "from_parameter": "p"
          }
        },
        "result": true
      }
    }
  },
  {
    "id": "extrema",
    "summary": "Minimum and maximum values",
    "description": "Two element array containing the minimum and the maximum values of `data`.\n\nThis process is basically an alias for calling both ``min()`` and ``max()``, but may be implemented more performant by back-ends as it only needs to iterate over the data once instead of twice.",
    "categories": [
      "math"
    ],
    "parameters": [
      {
        "name": "data",
        "description": "An array of numbers.",
        "schema": {
          "type": "array",
          "items": {
            "type": [
              "number",
              "null"
            ]
          }
        }
      },
      {
        "name": "ignore_nodata",
        "description": "Indicates whether no-data values are ignored or not. Ignores them by default. Setting this flag to `false` considers no-data values so that an array with two `null` values is returned if any value is such a value.",
        "schema": {
          "type": "boolean"
        },
        "default": true,
        "optional": true
      }
    ],
    "returns": {
      "description": "An array containing the minimum and maximum values for the specified numbers. The first element is the minimum, the second element is the maximum. If the input array is empty both elements are set to `null`.",
      "schema": [
        {
          "type": "array",
          "minItems": 2,
          "maxItems": 2,
          "items": {
            "type": [
              "number"
            ]
          }
        },
        {
          "type": "array",
          "minItems": 2,
          "maxItems": 2,
          "items": {
            "type": [
              "null"
            ]
          }
        }
      ]
    },
    "examples": [
      {
        "arguments": {
          "data": [
            1,
            0,
            3,
            2
          ]
        },
        "returns": [
          0,
          3
        ]
      },
      {
        "arguments": {
          "data": [
            5,
            2.5,
            null,
            -0.7
          ]
        },
        "returns": [
          -0.7,
          5
        ]
      },
      {
        "arguments": {
          "data": [
            1,
            0,
            3,
            null,
            2
          ],
          "ignore_nodata": false
        },
        "returns": [
          null,
          null
        ]
      },
      {
        "description": "The input array is empty: return two `null` values.",
        "arguments": {
          "data": []
        },
        "returns": [
          null,
          null
        ]
      }
    ]
  },
  {
    "id": "filter_bands",
    "summary": "Filter the bands by name",
    "description": "Filters the bands in the data cube so that bands that don't match any of the criteria are dropped from the data cube. The data cube is expected to have only one dimension of type `bands`. Fails with a `DimensionMissing` error if no such dimension exists.\n\nThe following criteria can be used to select bands:\n\n* `bands`: band name or common band name (e.g. `B01`, `B8A`, `red` or `nir`)\n* `wavelengths`: ranges of wavelengths in micrometres (m) (e.g. 0.5 - 0.6)\n\nAll these information are exposed in the band metadata of the collection. To keep algorithms interoperable it is recommended to prefer the common bands names or the wavelengths over collection and/or back-end specific band names.\n\nIf multiple criteria are specified, any of them must match and not all of them, i.e. they are combined with an OR-operation. If no criteria is specified, the `BandFilterParameterMissing` exception must be thrown.\n\n**Important:** The order of the specified array defines the order of the bands in the data cube, which can be important for subsequent processes. If multiple bands are matched by a single criterion (e.g. a range of wavelengths), they stay in the original order.",
    "categories": [
      "filter"
    ],
    "parameters": [
      {
        "name": "data",
        "description": "A data cube with bands.",
        "schema": {
          "type": "object",
          "subtype": "raster-cube"
        }
      },
      {
        "name": "bands",
        "description": "A list of band names. Either the unique band name (metadata field `name` in bands) or one of the common band names (metadata field `common_name` in bands). If unique band name and common name conflict, the unique band name has higher priority.\n\nThe order of the specified array defines the order of the bands in the data cube. If multiple bands match a common name, all matched bands are included in the original order.",
        "schema": {
          "type": "array",
          "items": {
            "type": "string",
            "subtype": "band-name"
          }
        },
        "default": [],
        "optional": true
      },
      {
        "name": "wavelengths",
        "description": "A list of sub-lists with each sub-list consisting of two elements. The first element is the minimum wavelength and the second element is the maximum wavelength. Wavelengths are specified in micrometres (m).\n\nThe order of the specified array defines the order of the bands in the data cube. If multiple bands match the wavelengths, all matched bands are included in the original order.",
        "schema": {
          "type": "array",
          "items": {
            "type": "array",
            "minItems": 2,
            "maxItems": 2,
            "items": {
              "type": "number"
            },
            "examples": [
              [
                [
                  0.45,
                  0.5
                ],
                [
                  0.6,
                  0.7
                ]
              ]
            ]
          }
        },
        "default": [],
        "optional": true
      }
    ],
    "returns": {
      "description": "A data cube limited to a subset of its original bands. Therefore, the cardinality is potentially lower, but the resolution and the number of dimensions are the same as for the original data cube.",
      "schema": {
        "type": "object",
        "subtype": "raster-cube"
      }
    },
    "exceptions": {
      "BandFilterParameterMissing": {
        "message": "The process 'filter_bands' requires any of the parameters 'bands', 'common_names' or 'wavelengths' to be set."
      },
      "DimensionMissing": {
        "message": "A band dimension is missing."
      }
    },
    "links": [
      {
        "rel": "about",
        "href": "https://github.com/radiantearth/stac-spec/tree/master/extensions/eo#common-band-names",
        "title": "List of common band names as specified by the STAC specification"
      }
    ]
  },
  {
    "id": "filter_bbox",
    "summary": "Spatial filter using a bounding box",
    "description": "Limits the data cube to the specified bounding box.\n\nThe filter retains a pixel in the data cube if the point at the pixel center intersects with the bounding box (as defined in the Simple Features standard by the OGC).",
    "categories": [
      "filter"
    ],
    "parameters": [
      {
        "name": "data",
        "description": "A data cube.",
        "schema": {
          "type": "object",
          "subtype": "raster-cube"
        }
      },
      {
        "name": "extent",
        "description": "A bounding box, which may include a vertical axis (see `base` and `height`).",
        "schema": {
          "type": "object",
          "subtype": "bounding-box",
          "required": [
            "west",
            "south",
            "east",
            "north"
          ],
          "properties": {
            "west": {
              "description": "West (lower left corner, coordinate axis 1).",
              "type": "number"
            },
            "south": {
              "description": "South (lower left corner, coordinate axis 2).",
              "type": "number"
            },
            "east": {
              "description": "East (upper right corner, coordinate axis 1).",
              "type": "number"
            },
            "north": {
              "description": "North (upper right corner, coordinate axis 2).",
              "type": "number"
            },
            "base": {
              "description": "Base (optional, lower left corner, coordinate axis 3).",
              "type": [
                "number",
                "null"
              ],
              "default": null
            },
            "height": {
              "description": "Height (optional, upper right corner, coordinate axis 3).",
              "type": [
                "number",
                "null"
              ],
              "default": null
            },
            "crs": {
              "description": "Coordinate reference system of the extent, specified as as [EPSG code](http://www.epsg-registry.org/), [WKT2 (ISO 19162) string](http://docs.opengeospatial.org/is/18-010r7/18-010r7.html) or [PROJ definition (deprecated)](https://proj.org/usage/quickstart.html). Defaults to `4326` (EPSG code 4326) unless the client explicitly requests a different coordinate reference system.",
              "anyOf": [
                {
                  "title": "EPSG Code",
                  "type": "integer",
                  "subtype": "epsg-code",
                  "minimum": 1000,
                  "examples": [
                    3857
                  ]
                },
                {
                  "title": "WKT2",
                  "type": "string",
                  "subtype": "wkt2-definition"
                },
                {
                  "title": "PROJ definition",
                  "type": "string",
                  "subtype": "proj-definition",
                  "deprecated": true
                }
              ],
              "default": 4326
            }
          }
        }
      }
    ],
    "returns": {
      "description": "A data cube restricted to the bounding box. Therefore, the cardinality is potentially lower, but the resolution and the number of dimensions are the same as for the original data cube.",
      "schema": {
        "type": "object",
        "subtype": "raster-cube"
      }
    },
    "links": [
      {
        "rel": "about",
        "href": "https://proj.org/usage/projections.html",
        "title": "PROJ parameters for cartographic projections"
      },
      {
        "rel": "about",
        "href": "http://www.epsg-registry.org",
        "title": "Official EPSG code registry"
      },
      {
        "rel": "about",
        "href": "http://www.epsg.io",
        "title": "Unofficial EPSG code database"
      },
      {
        "href": "http://www.opengeospatial.org/standards/sfa",
        "rel": "about",
        "title": "Simple Features standard by the OGC"
      }
    ]
  },
  {
    "id": "filter_labels",
    "summary": "Filter dimension labels based on a condition",
    "description": "Filters the dimension labels in the data cube for the given dimension. Only the dimension labels that match the specified condition are preserved, all other labels with their corresponding data get removed.",
    "categories": [
      "cubes",
      "filter"
    ],
    "parameters": [
      {
        "name": "data",
        "description": "A data cube.",
        "schema": {
          "type": "object",
          "subtype": "raster-cube"
        }
      },
      {
        "name": "condition",
        "description": "A condition that is evaluated against each dimension label in the specified dimension. A dimension label and the corresponding data is preserved for the given dimension, if the condition returns `true`.",
        "schema": {
          "type": "object",
          "subtype": "process-graph",
          "parameters": [
            {
              "name": "value",
              "description": "A single dimension label to compare against. The data type of the parameter depends on the dimension labels stored for the dimension.",
              "schema": [
                {
                  "type": "number"
                },
                {
                  "type": "string"
                }
              ]
            },
            {
              "name": "context",
              "description": "Additional data passed by the user.",
              "schema": {
                "description": "Any data type."
              },
              "optional": true,
              "default": null
            }
          ]
        }
      },
      {
        "name": "dimension",
        "description": "The name of the dimension to filter on. Fails with a `DimensionNotAvailable` error if the specified dimension does not exist.\n\n**Remarks:**\n\n* The default dimensions a data cube provides are described in the collection's metadata field `cube:dimensions`.\n* There could be multiple spatial dimensions such as `x`, `y` or `z`.\n* For multi-spectral imagery there is usually a separate dimension of type `bands` for the bands.",
        "schema": {
          "type": "string"
        }
      },
      {
        "name": "context",
        "description": "Additional data to be passed to the condition.",
        "schema": {
          "description": "Any data type."
        },
        "optional": true,
        "default": null
      }
    ],
    "returns": {
      "description": "The filtered data cube. Therefore, the cardinality of the dimension is potentially lower, but the resolution and the number of dimensions are the same as for the original data cube.",
      "schema": {
        "type": "object",
        "subtype": "raster-cube"
      }
    },
    "exceptions": {
      "DimensionNotAvailable": {
        "message": "A dimension with the specified name does not exist."
      }
    },
    "examples": [
      {
        "description": "Filters the data cube to only contain data from platform Sentinel-2A. This example assumes that the data cube has a dimension `platform` so that computations can distinguish between Sentinel-2A and Sentinel-2B data.",
        "process_graph": {
          "filter": {
            "process_id": "filter_labels",
            "arguments": {
              "data": {
                "from_parameter": "sentinel2_data"
              },
              "condition": {
                "process_graph": {
                  "eq": {
                    "process_id": "eq",
                    "arguments": {
                      "x": {
                        "from_parameter": "value"
                      },
                      "y": "Sentinel-2A",
                      "case_sensitive": false
                    },
                    "result": true
                  }
                }
              },
              "dimension": "platform"
            },
            "result": true
          }
        }
      }
    ]
  },
  {
    "id": "filter_spatial",
    "summary": "Spatial filter using geometries",
    "description": "Limits the data cube over the spatial dimensions to the specified geometries.\n\n- For **polygons**, the filter retains a pixel in the data cube if the point at the pixel center intersects with at least one of the polygons (as defined in the Simple Features standard by the OGC).\n- For **points**, the process considers the closest pixel center.\n- For **lines** (line strings), the process considers all the pixels whose centers are closest to at least one point on the line.\n\nMore specifically, pixels outside of the bounding box of the given geometry will not be available after filtering. All pixels inside the bounding box that are not retained will be set to `null` (no data).",
    "categories": [
      "filter"
    ],
    "parameters": [
      {
        "name": "data",
        "description": "A data cube.",
        "schema": {
          "type": "object",
          "subtype": "raster-cube"
        }
      },
      {
        "name": "geometries",
        "description": "One or more geometries used for filtering, specified as GeoJSON.",
        "schema": {
          "type": "object",
          "subtype": "geojson"
        }
      }
    ],
    "returns": {
      "description": "A data cube restricted to the specified geometries. Therefore, the cardinality is potentially lower, but the resolution and the number of dimensions are the same as for the original data cube.",
      "schema": {
        "type": "object",
        "subtype": "raster-cube"
      }
    },
    "links": [
      {
        "href": "http://www.opengeospatial.org/standards/sfa",
        "rel": "about",
        "title": "Simple Features standard by the OGC"
      }
    ]
  },
  {
    "id": "filter_temporal",
    "summary": "Temporal filter for a temporal intervals",
    "description": "Limits the data cube to the specified interval of dates and/or times.\n\nMore precisely, the filter checks whether the temporal dimension label is greater than or equal to the lower boundary (start date/time) and the temporal dimension label is less than the value of the upper boundary (end date/time). This corresponds to a left-closed interval, which contains the lower boundary but not the upper boundary.\n\nIf the dimension is set to `null` (it's the default value), the data cube is expected to only have one temporal dimension.",
    "categories": [
      "filter"
    ],
    "parameters": [
      {
        "name": "data",
        "description": "A data cube.",
        "schema": {
          "type": "object",
          "subtype": "raster-cube"
        }
      },
      {
        "name": "extent",
        "description": "Left-closed temporal interval, i.e. an array with exactly two elements:\n\n1. The first element is the start of the temporal interval. The specified instance in time is **included** in the interval.\n2. The second element is the end of the temporal interval. The specified instance in time is **excluded** from the interval.\n\nThe specified temporal strings follow [RFC 3339](https://tools.ietf.org/html/rfc3339). Also supports open intervals by setting one of the boundaries to `null`, but never both.",
        "schema": {
          "type": "array",
          "subtype": "temporal-interval",
          "minItems": 2,
          "maxItems": 2,
          "items": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time",
                "subtype": "date-time"
              },
              {
                "type": "string",
                "format": "date",
                "subtype": "date"
              },
              {
                "type": "null"
              }
            ]
          },
          "examples": [
            [
              "2015-01-01T00:00:00Z",
              "2016-01-01T00:00:00Z"
            ],
            [
              "2015-01-01",
              "2016-01-01"
            ]
          ]
        }
      },
      {
        "name": "dimension",
        "description": "The name of the temporal dimension to filter on. If the dimension is not set or is set to `null`, the filter applies to all temporal dimensions. Fails with a `DimensionNotAvailable` error if the specified dimension does not exist.\n\n**Note:** The default dimensions a data cube provides are described in the collection's metadata field `cube:dimensions`.",
        "schema": {
          "type": [
            "string",
            "null"
          ]
        },
        "default": null,
        "optional": true
      }
    ],
    "returns": {
      "description": "A data cube restricted to the specified temporal extent. Therefore, the cardinality is potentially lower, but the resolution and the number of dimensions are the same as for the original data cube.",
      "schema": {
        "type": "object",
        "subtype": "raster-cube"
      }
    },
    "exceptions": {
      "DimensionNotAvailable": {
        "message": "A dimension with the specified name does not exist."
      }
    }
  },
  {
    "id": "first",
    "summary": "First element",
    "description": "Gives the first element of an array. For an empty array `null` is returned.",
    "categories": [
      "arrays",
      "reducer"
    ],
    "parameters": [
      {
        "name": "data",
        "description": "An array with elements of any data type. An empty array resolves always with `null`.",
        "schema": {
          "type": "array",
          "items": {
            "description": "Any data type is allowed."
          }
        }
      },
      {
        "name": "ignore_nodata",
        "description": "Indicates whether no-data values are ignored or not. Ignores them by default. Setting this flag to `false` considers no-data values so that `null` is returned if the first value is such a value.",
        "schema": {
          "type": "boolean"
        },
        "default": true,
        "optional": true
      }
    ],
    "returns": {
      "description": "The first element of the input array.",
      "schema": {
        "description": "Any data type is allowed."
      }
    },
    "examples": [
      {
        "arguments": {
          "data": [
            1,
            0,
            3,
            2
          ]
        },
        "returns": 1
      },
      {
        "arguments": {
          "data": [
            null,
            "A",
            "B"
          ]
        },
        "returns": "A"
      },
      {
        "arguments": {
          "data": [
            null,
            2,
            3
          ],
          "ignore_nodata": false
        },
        "returns": null
      },
      {
        "description": "The input array is empty: return `null`.",
        "arguments": {
          "data": []
        },
        "returns": null
      }
    ]
  },
  {
    "id": "floor",
    "summary": "Round fractions down",
    "description": "The greatest integer less than or equal to the number `x`.\n\nThis process is *not* an alias for the ``int()`` process as defined by some mathematicians, see the examples for negative numbers in both processes for differences.\n\nThe no-data value `null` is passed through and therefore gets propagated.",
    "categories": [
      "math > rounding"
    ],
    "parameters": [
      {
        "name": "x",
        "description": "A number to round down.",
        "schema": {
          "type": [
            "number",
            "null"
          ]
        }
      }
    ],
    "returns": {
      "description": "The number rounded down.",
      "schema": {
        "type": [
          "integer",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "x": 0
        },
        "returns": 0
      },
      {
        "arguments": {
          "x": 3.5
        },
        "returns": 3
      },
      {
        "arguments": {
          "x": -0.4
        },
        "returns": -1
      },
      {
        "arguments": {
          "x": -3.5
        },
        "returns": -4
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "http://mathworld.wolfram.com/FloorFunction.html",
        "title": "Floor explained by Wolfram MathWorld"
      }
    ]
  },
  {
    "id": "gt",
    "summary": "Greater than comparison",
    "description": "Compares whether `x` is strictly greater than `y`.\n\n**Remarks:**\n\n* If any operand is `null`, the return value is `null`.\n* If any operand is an array or object, the return value is `false`.\n* If any operand is not a `number` or temporal string (`date`, `time` or `date-time`), the process returns `false`.\n* Temporal strings can *not* be compared based on their string representation due to the time zone / time-offset representations.",
    "categories": [
      "comparison"
    ],
    "parameters": [
      {
        "name": "x",
        "description": "First operand.",
        "schema": {
          "description": "Any data type is allowed."
        }
      },
      {
        "name": "y",
        "description": "Second operand.",
        "schema": {
          "description": "Any data type is allowed."
        }
      }
    ],
    "returns": {
      "description": "`true` if `x` is strictly greater than `y` or `null` if any operand is `null`, otherwise `false`.",
      "schema": {
        "type": [
          "boolean",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "x": 1,
          "y": null
        },
        "returns": null
      },
      {
        "arguments": {
          "x": 0,
          "y": 0
        },
        "returns": false
      },
      {
        "arguments": {
          "x": 2,
          "y": 1
        },
        "returns": true
      },
      {
        "arguments": {
          "x": -0.5,
          "y": -0.6
        },
        "returns": true
      },
      {
        "arguments": {
          "x": "00:00:00Z",
          "y": "00:00:00+01:00"
        },
        "returns": true
      },
      {
        "arguments": {
          "x": "1950-01-01T00:00:00Z",
          "y": "2018-01-01T12:00:00Z"
        },
        "returns": false
      },
      {
        "arguments": {
          "x": "2018-01-01T12:00:00+00:00",
          "y": "2018-01-01T12:00:00Z"
        },
        "returns": false
      },
      {
        "arguments": {
          "x": true,
          "y": 0
        },
        "returns": false
      },
      {
        "arguments": {
          "x": true,
          "y": false
        },
        "returns": false
      }
    ]
  },
  {
    "id": "gte",
    "summary": "Greater than or equal to comparison",
    "description": "Compares whether `x` is greater than or equal to `y`.\n\n**Remarks:**\n\n* If any operand is `null`, the return value is `null`. Therefore, `gte(null, null)` returns `null` instead of `true`.\n* If any operand is an array or object, the return value is `false`.\n* If the operands are not equal (see process ``eq()``) and any of them is not a `number` or temporal string (`date`, `time` or `date-time`), the process returns `false`.\n* Temporal strings can *not* be compared based on their string representation due to the time zone / time-offset representations.",
    "categories": [
      "comparison"
    ],
    "parameters": [
      {
        "name": "x",
        "description": "First operand.",
        "schema": {
          "description": "Any data type is allowed."
        }
      },
      {
        "name": "y",
        "description": "Second operand.",
        "schema": {
          "description": "Any data type is allowed."
        }
      }
    ],
    "returns": {
      "description": "`true` if `x` is greater than or equal to `y`, `null` if any operand is `null`, otherwise `false`.",
      "schema": {
        "type": [
          "boolean",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "x": 1,
          "y": null
        },
        "returns": null
      },
      {
        "arguments": {
          "x": 0,
          "y": 0
        },
        "returns": true
      },
      {
        "arguments": {
          "x": 1,
          "y": 2
        },
        "returns": false
      },
      {
        "arguments": {
          "x": -0.5,
          "y": -0.6
        },
        "returns": true
      },
      {
        "arguments": {
          "x": "00:00:00Z",
          "y": "00:00:00+01:00"
        },
        "returns": true
      },
      {
        "arguments": {
          "x": "1950-01-01T00:00:00Z",
          "y": "2018-01-01T12:00:00Z"
        },
        "returns": false
      },
      {
        "arguments": {
          "x": "2018-01-01T12:00:00+00:00",
          "y": "2018-01-01T12:00:00Z"
        },
        "returns": true
      },
      {
        "arguments": {
          "x": true,
          "y": false
        },
        "returns": false
      },
      {
        "arguments": {
          "x": [
            1,
            2,
            3
          ],
          "y": [
            1,
            2,
            3
          ]
        },
        "returns": false
      }
    ],
    "process_graph": {
      "eq": {
        "process_id": "eq",
        "arguments": {
          "x": {
            "from_parameter": "x"
          },
          "y": {
            "from_parameter": "y"
          }
        }
      },
      "gt": {
        "process_id": "gt",
        "arguments": {
          "x": {
            "from_parameter": "x"
          },
          "y": {
            "from_parameter": "y"
          }
        }
      },
      "or": {
        "process_id": "or",
        "arguments": {
          "x": {
            "from_node": "gt"
          },
          "y": {
            "from_node": "eq"
          }
        },
        "result": true
      }
    }
  },
  {
    "id": "if",
    "summary": "If-Then-Else conditional",
    "description": "If the value passed is `true`, returns the value of the `accept` parameter, otherwise returns the value of the `reject` parameter.\n\nThis is basically an if-then-else construct as in other programming languages.",
    "categories": [
      "logic",
      "comparison",
      "masks"
    ],
    "parameters": [
      {
        "name": "value",
        "description": "A boolean value.",
        "schema": {
          "type": [
            "boolean",
            "null"
          ]
        }
      },
      {
        "name": "accept",
        "description": "A value that is returned if the boolean value is `true`.",
        "schema": {
          "description": "Any data type is allowed."
        }
      },
      {
        "name": "reject",
        "description": "A value that is returned if the boolean value is **not** `true`. Defaults to `null`.",
        "schema": {
          "description": "Any data type is allowed."
        },
        "default": null,
        "optional": true
      }
    ],
    "returns": {
      "description": "Either the `accept` or `reject` argument depending on the given boolean value.",
      "schema": {
        "description": "Any data type is allowed."
      }
    },
    "examples": [
      {
        "arguments": {
          "value": true,
          "accept": "A",
          "reject": "B"
        },
        "returns": "A"
      },
      {
        "arguments": {
          "value": null,
          "accept": "A",
          "reject": "B"
        },
        "returns": "B"
      },
      {
        "arguments": {
          "value": false,
          "accept": [
            1,
            2,
            3
          ],
          "reject": [
            4,
            5,
            6
          ]
        },
        "returns": [
          4,
          5,
          6
        ]
      },
      {
        "arguments": {
          "value": true,
          "accept": 123
        },
        "returns": 123
      },
      {
        "arguments": {
          "value": false,
          "accept": 1
        },
        "returns": null
      }
    ]
  },
  {
    "id": "int",
    "summary": "Integer part of a number",
    "description": "The integer part of the real number `x`.\n\nThis process is *not* an alias for the ``floor()`` process as defined by some mathematicians, see the examples for negative numbers in both processes for differences.\n\nThe no-data value `null` is passed through and therefore gets propagated.",
    "categories": [
      "math",
      "math > rounding"
    ],
    "parameters": [
      {
        "name": "x",
        "description": "A number.",
        "schema": {
          "type": [
            "number",
            "null"
          ]
        }
      }
    ],
    "returns": {
      "description": "Integer part of the number.",
      "schema": {
        "type": [
          "integer",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "x": 0
        },
        "returns": 0
      },
      {
        "arguments": {
          "x": 3.5
        },
        "returns": 3
      },
      {
        "arguments": {
          "x": -0.4
        },
        "returns": 0
      },
      {
        "arguments": {
          "x": -3.5
        },
        "returns": -3
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "http://mathworld.wolfram.com/IntegerPart.html",
        "title": "Integer Part explained by Wolfram MathWorld"
      }
    ]
  },
  {
    "id": "is_nan",
    "summary": "Value is not a number",
    "description": "Checks whether the specified value `x` is not a number (often abbreviated as `NaN`). The definition of `NaN` follows the [IEEE Standard 754](https://ieeexplore.ieee.org/document/4610935). All non-numeric data types MUST also return `true`.",
    "categories": [
      "comparison"
    ],
    "parameters": [
      {
        "name": "x",
        "description": "The data to check.",
        "schema": {
          "description": "Any data type is allowed."
        }
      }
    ],
    "returns": {
      "description": "`true` if the data is not a number, otherwise `false`",
      "schema": {
        "type": "boolean"
      }
    },
    "examples": [
      {
        "arguments": {
          "x": 1
        },
        "returns": false
      },
      {
        "arguments": {
          "x": "Test"
        },
        "returns": true
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "https://ieeexplore.ieee.org/document/4610935",
        "title": "IEEE Standard 754-2008 for Floating-Point Arithmetic"
      }
    ]
  },
  {
    "id": "is_nodata",
    "summary": "Value is not a no-data value",
    "description": "Checks whether the specified data is a missing data, i.e. equals to any of the no-data values / `null`.",
    "categories": [
      "comparison"
    ],
    "parameters": [
      {
        "name": "x",
        "description": "The data to check.",
        "schema": {
          "description": "Any data type is allowed."
        }
      }
    ],
    "returns": {
      "description": "`true` if the data is a no-data value, otherwise `false`",
      "schema": {
        "type": "boolean"
      }
    },
    "examples": [
      {
        "arguments": {
          "x": 1
        },
        "returns": false
      },
      {
        "arguments": {
          "x": "Test"
        },
        "returns": false
      },
      {
        "arguments": {
          "x": null
        },
        "returns": true
      }
    ]
  },
  {
    "id": "is_valid",
    "summary": "Value is valid data",
    "description": "Checks whether the specified value `x` is valid. A value is considered valid if it is\n\n1. not a no-data value (`null`) and\n2. a finite number (only if `x` is a number). The definition of finite and infinite numbers follows the [IEEE Standard 754](https://ieeexplore.ieee.org/document/4610935).",
    "categories": [
      "comparison"
    ],
    "parameters": [
      {
        "name": "x",
        "description": "The data to check.",
        "schema": {
          "description": "Any data type is allowed."
        }
      }
    ],
    "returns": {
      "description": "`true` if the data is valid, otherwise `false`.",
      "schema": {
        "type": "boolean"
      }
    },
    "examples": [
      {
        "arguments": {
          "x": 1
        },
        "returns": true
      },
      {
        "arguments": {
          "x": "Test"
        },
        "returns": true
      },
      {
        "arguments": {
          "x": null
        },
        "returns": false
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "https://ieeexplore.ieee.org/document/4610935",
        "title": "IEEE Standard 754-2008 for Floating-Point Arithmetic"
      }
    ]
  },
  {
    "id": "last",
    "summary": "Last element",
    "description": "Gives the last element of an array. For an empty array `null` is returned.",
    "categories": [
      "arrays",
      "reducer"
    ],
    "parameters": [
      {
        "name": "data",
        "description": "An array with elements of any data type. An empty array resolves always with `null`.",
        "schema": {
          "type": "array",
          "items": {
            "description": "Any data type is allowed."
          }
        }
      },
      {
        "name": "ignore_nodata",
        "description": "Indicates whether no-data values are ignored or not. Ignores them by default. Setting this flag to `false` considers no-data values so that `null` is returned if the last value is such a value.",
        "schema": {
          "type": "boolean"
        },
        "default": true,
        "optional": true
      }
    ],
    "returns": {
      "description": "The last element of the input array.",
      "schema": {
        "description": "Any data type is allowed."
      }
    },
    "examples": [
      {
        "arguments": {
          "data": [
            1,
            0,
            3,
            2
          ]
        },
        "returns": 2
      },
      {
        "arguments": {
          "data": [
            "A",
            "B",
            null
          ]
        },
        "returns": "B"
      },
      {
        "arguments": {
          "data": [
            0,
            1,
            null
          ],
          "ignore_nodata": false
        },
        "returns": null
      },
      {
        "description": "The input array is empty: return `null`.",
        "arguments": {
          "data": []
        },
        "returns": null
      }
    ]
  },
  {
    "id": "linear_scale_range",
    "summary": "Linear transformation between two ranges",
    "description": "Performs a linear transformation between the input and output range.\n\nThe underlying formula is: *((x - inputMin) / (inputMax - inputMin)) * (outputMax - outputMin) + outputMin*.\n\nPotential use case include\n\n* scaling values to the 8-bit range (0 - 255) often used for numeric representation of values in one of the channels of the [RGB colour model](https://en.wikipedia.org/wiki/RGB_color_model#Numeric_representations) or\n* calculating percentages (0 - 100).\n\nThe no-data value `null` is passed through and therefore gets propagated.",
    "categories": [
      "math"
    ],
    "parameters": [
      {
        "name": "x",
        "description": "A number to transform.",
        "schema": {
          "type": [
            "number",
            "null"
          ]
        }
      },
      {
        "name": "inputMin",
        "description": "Minimum value the input can obtain.",
        "schema": {
          "type": "number"
        }
      },
      {
        "name": "inputMax",
        "description": "Maximum value the input can obtain.",
        "schema": {
          "type": "number"
        }
      },
      {
        "name": "outputMin",
        "description": "Minimum value of the desired output range.",
        "schema": {
          "type": "number"
        },
        "default": 0,
        "optional": true
      },
      {
        "name": "outputMax",
        "description": "Maximum value of the desired output range.",
        "schema": {
          "type": "number"
        },
        "default": 1,
        "optional": true
      }
    ],
    "returns": {
      "description": "The transformed number.",
      "schema": {
        "type": [
          "number",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "x": 0.3,
          "inputMin": -1,
          "inputMax": 1,
          "outputMin": 0,
          "outputMax": 255
        },
        "returns": 165.75
      },
      {
        "arguments": {
          "x": 25.5,
          "inputMin": 0,
          "inputMax": 255
        },
        "returns": 0.1
      },
      {
        "arguments": {
          "x": null,
          "inputMin": 0,
          "inputMax": 100
        },
        "returns": null
      }
    ],
    "process_graph": {
      "subtract1": {
        "process_id": "subtract",
        "arguments": {
          "x": {
            "from_parameter": "x"
          },
          "y": {
            "from_parameter": "inputMin"
          }
        }
      },
      "subtract2": {
        "process_id": "subtract",
        "arguments": {
          "x": {
            "from_parameter": "inputMax"
          },
          "y": {
            "from_parameter": "inputMin"
          }
        }
      },
      "subtract3": {
        "process_id": "subtract",
        "arguments": {
          "x": {
            "from_parameter": "outputMax"
          },
          "y": {
            "from_parameter": "outputMin"
          }
        }
      },
      "divide": {
        "process_id": "divide",
        "arguments": {
          "x": {
            "from_node": "subtract1"
          },
          "y": {
            "from_node": "subtract2"
          }
        }
      },
      "multiply": {
        "process_id": "multiply",
        "arguments": {
          "x": {
            "from_node": "divide"
          },
          "y": {
            "from_node": "subtract3"
          }
        }
      },
      "add": {
        "process_id": "add",
        "arguments": {
          "x": {
            "from_node": "multiply"
          },
          "y": {
            "from_parameter": "outputMin"
          }
        },
        "result": true
      }
    }
  },
  {
    "id": "ln",
    "summary": "Natural logarithm",
    "description": "The natural logarithm is the logarithm to the base *e* of the number `x`, which equals to using the *log* process with the base set to *e*. The natural logarithm is the inverse function of taking *e* to the power x.\n\nThe no-data value `null` is passed through.\n\nThe computations follow [IEEE Standard 754](https://ieeexplore.ieee.org/document/8766229) whenever the processing environment supports it. Therefore, `ln(0)` results in infinity if the processing environment supports it or otherwise an error is thrown.",
    "categories": [
      "math > exponential & logarithmic"
    ],
    "parameters": [
      {
        "name": "x",
        "description": "A number to compute the natural logarithm for.",
        "schema": {
          "type": [
            "number",
            "null"
          ]
        }
      }
    ],
    "returns": {
      "description": "The computed natural logarithm.",
      "schema": {
        "type": [
          "number",
          "null"
        ]
      }
    },
    "examples": [
      {
        "title": "Example for ln(e) = 1",
        "process_graph": {
          "e1": {
            "process_id": "e",
            "arguments": {}
          },
          "ln1": {
            "process_id": "ln",
            "arguments": {
              "data": {
                "from_node": "e1"
              }
            },
            "result": true
          }
        },
        "returns": 1
      },
      {
        "arguments": {
          "x": 1
        },
        "returns": 0
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "http://mathworld.wolfram.com/NaturalLogarithm.html",
        "title": "Natural logarithm explained by Wolfram MathWorld"
      },
      {
        "rel": "about",
        "href": "https://ieeexplore.ieee.org/document/8766229",
        "title": "IEEE Standard 754-2019 for Floating-Point Arithmetic"
      }
    ],
    "process_graph": {
      "e": {
        "process_id": "e",
        "arguments": {}
      },
      "log": {
        "process_id": "log",
        "arguments": {
          "x": {
            "from_parameter": "x"
          },
          "base": {
            "from_node": "e"
          }
        },
        "result": true
      }
    }
  },
  {
    "id": "load_collection",
    "summary": "Load a collection",
    "description": "Loads a collection from the current back-end by its id and returns it as processable data cube. The data that is added to the data cube can be restricted with the additional `spatial_extent`, `temporal_extent`, `bands` and `properties`.\n\n**Remarks:**\n\n* The bands (and all dimensions that specify nominal dimension labels) are expected to be ordered as specified in the metadata if the `bands` parameter is set to `null`.\n* If no additional parameter is specified this would imply that the whole data set is expected to be loaded. Due to the large size of many data sets this is not recommended and may be optimized by back-ends to only load the data that is actually required after evaluating subsequent processes such as filters. This means that the pixel values should be processed only after the data has been limited to the required extents and as a consequence also to a manageable size.",
    "categories": [
      "cubes",
      "import"
    ],
    "parameters": [
      {
        "name": "id",
        "description": "The collection id.",
        "schema": {
          "type": "string",
          "subtype": "collection-id",
          "pattern": "^[\\w\\-\\.~/]+$"
        }
      },
      {
        "name": "spatial_extent",
        "description": "Limits the data to load from the collection to the specified bounding box or polygons.\n\nThe process puts a pixel into the data cube if the point at the pixel center intersects with the bounding box or any of the polygons (as defined in the Simple Features standard by the OGC).\n\nThe GeoJSON can be one of the following GeoJSON types:\n\n* A `Polygon` geometry,\n* a `GeometryCollection` containing Polygons,\n* a `Feature` with a `Polygon` geometry or\n* a `FeatureCollection` containing `Feature`s with a `Polygon` geometry.\n\nSet this parameter to `null` to set no limit for the spatial extent. Be careful with this when loading large datasets!",
        "schema": [
          {
            "title": "Bounding Box",
            "type": "object",
            "subtype": "bounding-box",
            "required": [
              "west",
              "south",
              "east",
              "north"
            ],
            "properties": {
              "west": {
                "description": "West (lower left corner, coordinate axis 1).",
                "type": "number"
              },
              "south": {
                "description": "South (lower left corner, coordinate axis 2).",
                "type": "number"
              },
              "east": {
                "description": "East (upper right corner, coordinate axis 1).",
                "type": "number"
              },
              "north": {
                "description": "North (upper right corner, coordinate axis 2).",
                "type": "number"
              },
              "base": {
                "description": "Base (optional, lower left corner, coordinate axis 3).",
                "type": [
                  "number",
                  "null"
                ],
                "default": null
              },
              "height": {
                "description": "Height (optional, upper right corner, coordinate axis 3).",
                "type": [
                  "number",
                  "null"
                ],
                "default": null
              },
              "crs": {
                "description": "Coordinate reference system of the extent, specified as as [EPSG code](http://www.epsg-registry.org/), [WKT2 (ISO 19162) string](http://docs.opengeospatial.org/is/18-010r7/18-010r7.html) or [PROJ definition (deprecated)](https://proj.org/usage/quickstart.html). Defaults to `4326` (EPSG code 4326) unless the client explicitly requests a different coordinate reference system.",
                "anyOf": [
                  {
                    "title": "EPSG Code",
                    "type": "integer",
                    "subtype": "epsg-code",
                    "minimum": 1000,
                    "examples": [
                      3857
                    ]
                  },
                  {
                    "title": "WKT2",
                    "type": "string",
                    "subtype": "wkt2-definition"
                  },
                  {
                    "title": "PROJ definition",
                    "type": "string",
                    "subtype": "proj-definition",
                    "deprecated": true
                  }
                ],
                "default": 4326
              }
            }
          },
          {
            "title": "GeoJSON",
            "type": "object",
            "subtype": "geojson"
          },
          {
            "title": "No filter",
            "description": "Don't filter spatially. All data is included in the data cube.",
            "type": "null"
          }
        ]
      },
      {
        "name": "temporal_extent",
        "description": "Limits the data to load from the collection to the specified left-closed temporal interval. Applies to all temporal dimensions. The interval has to be specified as an array with exactly two elements:\n\n1. The first element is the start of the temporal interval. The specified instance in time is **included** in the interval.\n2. The second element is the end of the temporal interval. The specified instance in time is **excluded** from the interval.\n\nThe specified temporal strings follow [RFC 3339](https://tools.ietf.org/html/rfc3339). Also supports open intervals by setting one of the boundaries to `null`, but never both.\n\nSet this parameter to `null` to set no limit for the spatial extent. Be careful with this when loading large datasets!",
        "schema": [
          {
            "type": "array",
            "subtype": "temporal-interval",
            "minItems": 2,
            "maxItems": 2,
            "items": {
              "anyOf": [
                {
                  "type": "string",
                  "format": "date-time",
                  "subtype": "date-time"
                },
                {
                  "type": "string",
                  "format": "date",
                  "subtype": "date"
                },
                {
                  "type": "null"
                }
              ]
            },
            "examples": [
              [
                "2015-01-01T00:00:00Z",
                "2016-01-01T00:00:00Z"
              ],
              [
                "2015-01-01",
                "2016-01-01"
              ]
            ]
          },
          {
            "title": "No filter",
            "description": "Don't filter temporally. All data is included in the data cube.",
            "type": "null"
          }
        ]
      },
      {
        "name": "bands",
        "description": "Only adds the specified bands into the data cube so that bands that don't match the list of band names are not available. Applies to all dimensions of type `bands`.\n\nEither the unique band name (metadata field `name` in bands) or one of the common band names (metadata field `common_name` in bands) can be specified. If unique band name and common name conflict, the unique band name has higher priority.\n\nThe order of the specified array defines the order of the bands in the data cube. f multiple bands match a common name, all matched bands are included in the original order.",
        "schema": [
          {
            "type": "array",
            "items": {
              "type": "string",
              "subtype": "band-name"
            }
          },
          {
            "title": "No filter",
            "description": "Don't filter bands. All bands are included in the data cube.",
            "type": "null"
          }
        ],
        "default": null,
        "optional": true
      },
      {
        "name": "properties",
        "description": "Limits the data by metadata properties to include only data in the data cube which all given conditions return `true` for (AND operation).\n\nSpecify key-value-pairs with the keys being the name of the metadata property, which can be retrieved with the openEO Data Discovery for Collections. The values must be conditions to be evaluated against the collection metadata, see the example.",
        "schema": [
          {
            "type": "object",
            "additionalProperties": {
              "type": "object",
              "subtype": "process-graph",
              "parameters": [
                {
                  "name": "value",
                  "description": "The property value to be checked against.",
                  "schema": {
                    "description": "Any data type."
                  }
                }
              ]
            }
          },
          {
            "title": "No filter",
            "description": "Don't filter by metadata properties.",
            "type": "null"
          }
        ],
        "default": null,
        "optional": true
      }
    ],
    "returns": {
      "description": "A data cube for further processing.",
      "schema": {
        "type": "object",
        "subtype": "raster-cube"
      }
    },
    "examples": [
      {
        "description": "Loading `Sentinel-2B` data from a `Sentinel-2` collection for 2018, but only with cloud cover between 0 and 50%.",
        "process_graph": {
          "loadco1": {
            "process_id": "load_collection",
            "arguments": {
              "id": "Sentinel-2",
              "spatial_extent": {
                "west": 16.1,
                "east": 16.6,
                "north": 48.6,
                "south": 47.2
              },
              "temporal_extent": [
                "2018-01-01",
                "2019-01-01"
              ],
              "properties": {
                "eo:cloud_cover": {
                  "process_graph": {
                    "cc": {
                      "process_id": "between",
                      "arguments": {
                        "x": {
                          "from_parameter": "value"
                        },
                        "min": 0,
                        "max": 50
                      },
                      "result": true
                    }
                  }
                },
                "platform": {
                  "process_graph": {
                    "pf": {
                      "process_id": "eq",
                      "arguments": {
                        "x": {
                          "from_parameter": "value"
                        },
                        "y": "Sentinel-2B",
                        "case_sensitive": false
                      },
                      "result": true
                    }
                  }
                }
              }
            },
            "result": true
          }
        }
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "https://proj.org/usage/projections.html",
        "title": "PROJ parameters for cartographic projections"
      },
      {
        "rel": "about",
        "href": "http://www.epsg-registry.org",
        "title": "Official EPSG code registry"
      },
      {
        "rel": "about",
        "href": "http://www.epsg.io",
        "title": "Unofficial EPSG code database"
      },
      {
        "href": "http://www.opengeospatial.org/standards/sfa",
        "rel": "about",
        "title": "Simple Features standard by the OGC"
      },
      {
        "rel": "about",
        "href": "https://github.com/radiantearth/stac-spec/tree/master/extensions/eo#common-band-names",
        "title": "List of common band names as specified by the STAC specification"
      }
    ]
  },
  {
    "id": "load_result",
    "summary": "Load batch job results",
    "description": "Loads batch job results by job id from the local user workspace / data store. The job must have been stored by the authenticated user on the back-end currently connected to.",
    "categories": [
      "cubes",
      "import"
    ],
    "parameters": [
      {
        "name": "id",
        "description": "The id of a batch job with results.",
        "schema": {
          "type": "string",
          "subtype": "job-id",
          "pattern": "^[\\w\\-\\.~]+$"
        }
      }
    ],
    "returns": {
      "description": "A data cube for further processing.",
      "schema": {
        "type": "object",
        "subtype": "raster-cube"
      }
    }
  },
  {
    "id": "load_uploaded_files",
    "summary": "Load files from the user workspace",
    "description": "Loads one or more user-uploaded files from the local user workspace / data store and returns them as a single data cube. The files must have been stored by the authenticated user on the back-end currently connected to.",
    "categories": [
      "cubes",
      "import"
    ],
    "parameters": [
      {
        "name": "paths",
        "description": "The files to read. Folders can't be specified, instead specify all files. An error is thrown if a file can't be read.",
        "schema": {
          "type": "array",
          "subtype": "file-paths",
          "items": {
            "type": "string",
            "subtype": "file-path"
          }
        }
      },
      {
        "name": "format",
        "description": "The file format to read from. It must be one of the values that the server reports as supported input file formats, which usually correspond to the short GDAL/OGR codes. This parameter is *case insensitive*.",
        "schema": {
          "type": "string",
          "subtype": "input-format"
        }
      },
      {
        "name": "options",
        "description": "The file format options to be used to read the files. Must correspond to the options that the server reports as supported options for the chosen `format`. The option names and valid values usually correspond to the GDAL/OGR format options.",
        "schema": {
          "type": "object",
          "subtype": "input-format-options"
        },
        "default": {},
        "optional": true
      }
    ],
    "returns": {
      "description": "A data cube for further processing.",
      "schema": {
        "type": "object",
        "subtype": "raster-cube"
      }
    }
  },
  {
    "id": "log",
    "summary": "Logarithm to a base",
    "description": "Logarithm to the base `base` of the number `x` is defined to be the inverse function of taking b to the power of x.\n\nThe no-data value `null` is passed through and therefore gets propagated if any of the arguments is `null`.\n\nThe computations follow [IEEE Standard 754](https://ieeexplore.ieee.org/document/8766229) whenever the processing environment supports it. Therefore, `log(0, 2)` results in infinity if the processing environment supports it or otherwise an error is thrown.",
    "categories": [
      "math > exponential & logarithmic"
    ],
    "parameters": [
      {
        "name": "x",
        "description": "A number to compute the logarithm for.",
        "schema": {
          "type": [
            "number",
            "null"
          ]
        }
      },
      {
        "name": "base",
        "description": "The numerical base.",
        "schema": {
          "type": [
            "number",
            "null"
          ]
        }
      }
    ],
    "returns": {
      "description": "The computed logarithm.",
      "schema": {
        "type": [
          "number",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "x": 10,
          "base": 10
        },
        "returns": 1
      },
      {
        "arguments": {
          "x": 2,
          "base": 2
        },
        "returns": 1
      },
      {
        "arguments": {
          "x": 4,
          "base": 2
        },
        "returns": 2
      },
      {
        "arguments": {
          "x": 1,
          "base": 16
        },
        "returns": 0
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "http://mathworld.wolfram.com/Logarithm.html",
        "title": "Logarithm explained by Wolfram MathWorld"
      },
      {
        "rel": "about",
        "href": "https://ieeexplore.ieee.org/document/8766229",
        "title": "IEEE Standard 754-2019 for Floating-Point Arithmetic"
      }
    ]
  },
  {
    "id": "lt",
    "summary": "Less than comparison",
    "description": "Compares whether `x` is strictly less than `y`.\n\n**Remarks:**\n\n* If any operand is `null`, the return value is `null`.\n* If any operand is an array or object, the return value is `false`.\n* If any operand is not a `number` or temporal string (`date`, `time` or `date-time`), the process returns `false`.\n* Temporal strings can *not* be compared based on their string representation due to the time zone / time-offset representations.",
    "categories": [
      "comparison"
    ],
    "parameters": [
      {
        "name": "x",
        "description": "First operand.",
        "schema": {
          "description": "Any data type is allowed."
        }
      },
      {
        "name": "y",
        "description": "Second operand.",
        "schema": {
          "description": "Any data type is allowed."
        }
      }
    ],
    "returns": {
      "description": "`true` if `x` is strictly less than `y`, `null` if any operand is `null`, otherwise `false`.",
      "schema": {
        "type": [
          "boolean",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "x": 1,
          "y": null
        },
        "returns": null
      },
      {
        "arguments": {
          "x": 0,
          "y": 0
        },
        "returns": false
      },
      {
        "arguments": {
          "x": 1,
          "y": 2
        },
        "returns": true
      },
      {
        "arguments": {
          "x": -0.5,
          "y": -0.6
        },
        "returns": false
      },
      {
        "arguments": {
          "x": "00:00:00+01:00",
          "y": "00:00:00Z"
        },
        "returns": true
      },
      {
        "arguments": {
          "x": "1950-01-01T00:00:00Z",
          "y": "2018-01-01T12:00:00Z"
        },
        "returns": true
      },
      {
        "arguments": {
          "x": "2018-01-01T12:00:00+00:00",
          "y": "2018-01-01T12:00:00Z"
        },
        "returns": false
      },
      {
        "arguments": {
          "x": 0,
          "y": true
        },
        "returns": false
      },
      {
        "arguments": {
          "x": false,
          "y": true
        },
        "returns": false
      }
    ]
  },
  {
    "id": "lte",
    "summary": "Less than or equal to comparison",
    "description": "Compares whether `x` is less than or equal to `y`.\n\n**Remarks:**\n\n* If any operand is `null`, the return value is `null`. Therefore, `lte(null, null)` returns `null` instead of `true`.\n* If any operand is an array or object, the return value is `false`.\n* If the operands are not equal (see process ``eq()``) and any of them is not a `number` or temporal string (`date`, `time` or `date-time`), the process returns `false`.\n* Temporal strings can *not* be compared based on their string representation due to the time zone / time-offset representations.",
    "categories": [
      "comparison"
    ],
    "parameters": [
      {
        "name": "x",
        "description": "First operand.",
        "schema": {
          "description": "Any data type is allowed."
        }
      },
      {
        "name": "y",
        "description": "Second operand.",
        "schema": {
          "description": "Any data type is allowed."
        }
      }
    ],
    "returns": {
      "description": "`true` if `x` is less than or equal to `y`, `null` if any operand is `null`, otherwise `false`.",
      "schema": {
        "type": [
          "boolean",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "x": 1,
          "y": null
        },
        "returns": null
      },
      {
        "arguments": {
          "x": 0,
          "y": 0
        },
        "returns": true
      },
      {
        "arguments": {
          "x": 1,
          "y": 2
        },
        "returns": true
      },
      {
        "arguments": {
          "x": -0.5,
          "y": -0.6
        },
        "returns": false
      },
      {
        "arguments": {
          "x": "00:00:00+01:00",
          "y": "00:00:00Z"
        },
        "returns": true
      },
      {
        "arguments": {
          "x": "1950-01-01T00:00:00Z",
          "y": "2018-01-01T12:00:00Z"
        },
        "returns": true
      },
      {
        "arguments": {
          "x": "2018-01-01T12:00:00+00:00",
          "y": "2018-01-01T12:00:00Z"
        },
        "returns": true
      },
      {
        "arguments": {
          "x": false,
          "y": true
        },
        "returns": false
      },
      {
        "arguments": {
          "x": [
            1,
            2,
            3
          ],
          "y": [
            1,
            2,
            3
          ]
        },
        "returns": false
      }
    ],
    "process_graph": {
      "eq": {
        "process_id": "eq",
        "arguments": {
          "x": {
            "from_parameter": "x"
          },
          "y": {
            "from_parameter": "y"
          }
        }
      },
      "lt": {
        "process_id": "lt",
        "arguments": {
          "x": {
            "from_parameter": "x"
          },
          "y": {
            "from_parameter": "y"
          }
        }
      },
      "or": {
        "process_id": "or",
        "arguments": {
          "x": {
            "from_node": "lt"
          },
          "y": {
            "from_node": "eq"
          }
        },
        "result": true
      }
    }
  },
  {
    "id": "mask_polygon",
    "summary": "Apply a polygon mask",
    "description": "Applies a polygon mask to a raster data cube. To apply a raster mask use ``mask()``.\n\nAll pixels for which the point at the pixel center **does not** intersect with any polygon (as defined in the Simple Features standard by the OGC) are replaced. This behaviour can be inverted by setting the parameter `inside` to `true`.\n\nThe pixel values are replaced with the value specified for `replacement`, which defaults to `null` (no data). No data values in `data` will be left untouched by the masking operation.",
    "categories": [
      "masks"
    ],
    "parameters": [
      {
        "name": "data",
        "description": "A raster data cube.",
        "schema": {
          "type": "object",
          "subtype": "raster-cube"
        }
      },
      {
        "name": "mask",
        "description": "A GeoJSON object containing a polygon. The provided feature types can be one of the following:\n\n* A `Polygon` geometry,\n* a `GeometryCollection` containing Polygons,\n* a `Feature` with a `Polygon` geometry or\n* a `FeatureCollection` containing `Feature`s with a `Polygon` geometry.",
        "schema": {
          "type": "object",
          "subtype": "geojson"
        }
      },
      {
        "name": "replacement",
        "description": "The value used to replace masked values with.",
        "schema": {
          "type": [
            "number",
            "boolean",
            "string",
            "null"
          ]
        },
        "default": null,
        "optional": true
      },
      {
        "name": "inside",
        "description": "If set to `true` all pixels for which the point at the pixel center **does** intersect with any polygon are replaced.",
        "schema": {
          "type": "boolean"
        },
        "default": false,
        "optional": true
      }
    ],
    "returns": {
      "description": "The masked raster data cube.",
      "schema": {
        "type": "object",
        "subtype": "raster-cube"
      }
    },
    "links": [
      {
        "href": "http://www.opengeospatial.org/standards/sfa",
        "rel": "about",
        "title": "Simple Features standard by the OGC"
      }
    ]
  },
  {
    "id": "mask",
    "summary": "Apply a raster mask",
    "description": "Applies a mask to a raster data cube. To apply a vector mask use ``mask_polygon()``.\n\nA mask is a raster data cube for which corresponding pixels among `data` and `mask` are compared and those pixels in `data` are replaced whose pixels in `mask` are non-zero (for numbers) or `true` (for boolean values). The pixel values are replaced with the value specified for `replacement`, which defaults to `null` (no data).\n\nThe data cubes have to be compatible so that each dimension in mask must also be available in the raster data cube with the same name, type, reference system, resolution and labels. Dimensions can be missing in the mask with the result that the mask is applied for each label of the missing dimension in the data cube. The process fails if there's an incompatibility found between the raster data cube and the mask.",
    "categories": [
      "masks"
    ],
    "parameters": [
      {
        "name": "data",
        "description": "A raster data cube.",
        "schema": {
          "type": "object",
          "subtype": "raster-cube"
        }
      },
      {
        "name": "mask",
        "description": "A mask as raster data cube. Every pixel in `data` must have a corresponding element in `mask`.",
        "schema": {
          "type": "object",
          "subtype": "raster-cube"
        }
      },
      {
        "name": "replacement",
        "description": "The value used to replace masked values with.",
        "schema": {
          "type": [
            "number",
            "boolean",
            "string",
            "null"
          ]
        },
        "default": null,
        "optional": true
      }
    ],
    "returns": {
      "description": "The masked raster data cube.",
      "schema": {
        "type": "object",
        "subtype": "raster-cube"
      }
    }
  },
  {
    "id": "max",
    "summary": "Maximum value",
    "description": "Computes the largest value of an array of numbers, which is is equal to the first element of a sorted (i.e., ordered) version the array.",
    "categories": [
      "math",
      "reducer"
    ],
    "parameters": [
      {
        "name": "data",
        "description": "An array of numbers. An empty array resolves always with `null`.",
        "schema": {
          "type": "array",
          "items": {
            "type": [
              "number",
              "null"
            ]
          }
        }
      },
      {
        "name": "ignore_nodata",
        "description": "Indicates whether no-data values are ignored or not. Ignores them by default. Setting this flag to `false` considers no-data values so that `null` is returned if any value is such a value.",
        "schema": {
          "type": "boolean"
        },
        "default": true,
        "optional": true
      }
    ],
    "returns": {
      "description": "The maximum value.",
      "schema": {
        "type": [
          "number",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "data": [
            1,
            0,
            3,
            2
          ]
        },
        "returns": 3
      },
      {
        "arguments": {
          "data": [
            5,
            2.5,
            null,
            -0.7
          ]
        },
        "returns": 5
      },
      {
        "arguments": {
          "data": [
            1,
            0,
            3,
            null,
            2
          ],
          "ignore_nodata": false
        },
        "returns": null
      },
      {
        "description": "The input array is empty: return `null`.",
        "arguments": {
          "data": []
        },
        "returns": null
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "http://mathworld.wolfram.com/Maximum.html",
        "title": "Maximum explained by Wolfram MathWorld"
      }
    ]
  },
  {
    "id": "mean",
    "summary": "Arithmetic mean (average)",
    "description": "The arithmetic mean of an array of numbers is the quantity commonly called the average. It is defined as the sum of all elements divided by the number of elements.",
    "categories": [
      "math",
      "reducer"
    ],
    "parameters": [
      {
        "name": "data",
        "description": "An array of numbers. An empty array resolves always with `null`.",
        "schema": {
          "type": "array",
          "items": {
            "type": [
              "number",
              "null"
            ]
          }
        }
      },
      {
        "name": "ignore_nodata",
        "description": "Indicates whether no-data values are ignored or not. Ignores them by default. Setting this flag to `false` considers no-data values so that `null` is returned if any value is such a value.",
        "schema": {
          "type": "boolean"
        },
        "default": true,
        "optional": true
      }
    ],
    "returns": {
      "description": "The computed arithmetic mean.",
      "schema": {
        "type": [
          "number",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "data": [
            1,
            0,
            3,
            2
          ]
        },
        "returns": 1.5
      },
      {
        "arguments": {
          "data": [
            9,
            2.5,
            null,
            -2.5
          ]
        },
        "returns": 3
      },
      {
        "arguments": {
          "data": [
            1,
            null
          ],
          "ignore_nodata": false
        },
        "returns": null
      },
      {
        "description": "The input array is empty: return `null`.",
        "arguments": {
          "data": []
        },
        "returns": null
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "http://mathworld.wolfram.com/ArithmeticMean.html",
        "title": "Arithmetic mean explained by Wolfram MathWorld"
      }
    ]
  },
  {
    "id": "median",
    "summary": "Statistical median",
    "description": "The statistical median of an array of numbers is the value separating the higher half from the lower half of the data.\n\n**Remarks:**\n\n* For a symmetric arrays, the result is equal to the ``mean()``.\n* The median can also be calculated by computing the quantile (see process ``quantiles()``) with the probability of *0.5*: `quantiles(data, [0.5])`.\n* An empty input array returns `null`.",
    "categories": [
      "math",
      "reducer"
    ],
    "parameters": [
      {
        "name": "data",
        "description": "An array of numbers. An empty array resolves always with `null`.",
        "schema": {
          "type": "array",
          "items": {
            "type": [
              "number",
              "null"
            ]
          }
        }
      },
      {
        "name": "ignore_nodata",
        "description": "Indicates whether no-data values are ignored or not. Ignores them by default. Setting this flag to `false` considers no-data values so that `null` is returned if any value is such a value.",
        "schema": {
          "type": "boolean"
        },
        "default": true,
        "optional": true
      }
    ],
    "returns": {
      "description": "The computed statistical median.",
      "schema": {
        "type": [
          "number",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "data": [
            1,
            3,
            3,
            6,
            7,
            8,
            9
          ]
        },
        "returns": 6
      },
      {
        "arguments": {
          "data": [
            1,
            2,
            3,
            4,
            5,
            6,
            8,
            9
          ]
        },
        "returns": 4.5
      },
      {
        "arguments": {
          "data": [
            -1,
            -0.5,
            null,
            1
          ]
        },
        "returns": -0.5
      },
      {
        "arguments": {
          "data": [
            -1,
            0,
            null,
            1
          ],
          "ignore_nodata": false
        },
        "returns": null
      },
      {
        "description": "The input array is empty: return `null`.",
        "arguments": {
          "data": []
        },
        "returns": null
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "http://mathworld.wolfram.com/StatisticalMedian.html",
        "title": "Statistical Median explained by Wolfram MathWorld"
      }
    ]
  },
  {
    "id": "merge_cubes",
    "summary": "Merging two data cubes",
    "description": "The data cubes have to be compatible. A merge operation without overlap should be reversible with (a set of) filter operations for each of the two cubes. The process performs the join on overlapping dimensions, with the same name and type.\n\nAn overlapping dimension has the same name, type, reference system and resolution in both dimensions, but can have different labels. One of the dimensions can have different labels, for all other dimensions the labels must be equal. If data overlaps, the parameter `overlap_resolver` must be specified to resolve the overlap.\n\n**Examples for merging two data cubes:**\n\n1. Data cubes with the dimensions `x`, `y`, `t` and `bands` have the same dimension labels in `x`,`y` and `t`, but the labels for the dimension `bands` are `B1` and `B2` for the first cube and `B3` and `B4`. An overlap resolver is *not needed*. The merged data cube has the dimensions `x`, `y`, `t` and `bands` and the dimension `bands` has four dimension labels: `B1`, `B2`, `B3`, `B4`.\n2. Data cubes with the dimensions `x`, `y`, `t` and `bands` have the same dimension labels in `x`,`y` and `t`, but the labels for the dimension `bands` are `B1` and `B2` for the first data cube and `B2` and `B3` for the second. An overlap resolver is *required* to resolve overlap in band `B2`. The merged data cube has the dimensions `x`, `y`, `t` and `bands` and the dimension `bands` has three dimension labels: `B1`, `B2`, `B3`.\n3. Data cubes with the dimensions `x`, `y` and `t` have the same dimension labels in `x`,`y` and `t`. There are two options:\n   1. Keep the overlapping values separately in the merged data cube: An overlap resolver is *not needed*, but for each data cube you need to add a new dimension using ``add_dimension()``. The new dimensions must be equal, except that the labels for the new dimensions must differ by name. The merged data cube has the same dimensions and labels as the original data cubes, plus the dimension added with ``add_dimension()``, which has the two dimension labels after the merge.\n   2. Combine the overlapping values into a single value: An overlap resolver is *required* to resolve the overlap for all pixels. The merged data cube has the same dimensions and labels as the original data cubes, but all pixel values have been processed by the overlap resolver.\n4. Merging a data cube with dimensions `x`, `y`, `t` with another cube with dimensions `x`, `y` will join on the `x`, `y` dimension, so the lower dimension cube is merged with each time step in the higher dimensional cube. This can for instance be used to apply a digital elevation model to a spatiotemporal data cube.",
    "categories": [
      "cubes"
    ],
    "parameters": [
      {
        "name": "cube1",
        "description": "The first data cube.",
        "schema": {
          "type": "object",
          "subtype": "raster-cube"
        }
      },
      {
        "name": "cube2",
        "description": "The second data cube.",
        "schema": {
          "type": "object",
          "subtype": "raster-cube"
        }
      },
      {
        "name": "overlap_resolver",
        "description": "A reduction operator that resolves the conflict if the data overlaps. The reducer must return a value of the same data type as the input values are. The reduction operator may be a single process such as ``multiply()`` or consist of multiple sub-processes. `null` (the default) can be specified if no overlap resolver is required.",
        "schema": {
          "type": "object",
          "subtype": "process-graph",
          "parameters": [
            {
              "name": "x",
              "description": "The first value.",
              "schema": {
                "description": "Any data type."
              }
            },
            {
              "name": "y",
              "description": "The second value.",
              "schema": {
                "description": "Any data type."
              }
            },
            {
              "name": "context",
              "description": "Additional data passed by the user.",
              "schema": {
                "description": "Any data type."
              },
              "optional": true,
              "default": null
            }
          ]
        },
        "default": null,
        "optional": true
      },
      {
        "name": "context",
        "description": "Additional data to be passed to the overlap resolver.",
        "schema": {
          "description": "Any data type."
        },
        "optional": true,
        "default": null
      }
    ],
    "returns": {
      "description": "The merged data cube.",
      "schema": {
        "type": "object",
        "subtype": "raster-cube"
      }
    },
    "exceptions": {
      "OverlapResolverMissing": {
        "message": "Overlapping data cubes, but no overlap resolver has been specified."
      }
    },
    "links": [
      {
        "rel": "about",
        "href": "https://en.wikipedia.org/wiki/Reduction_Operator",
        "title": "Background information on reduction operators (binary reducers) by Wikipedia"
      }
    ]
  },
  {
    "id": "min",
    "summary": "Minimum value",
    "description": "Computes the smallest value of an array of numbers, which is is equal to the last element of a sorted (i.e., ordered) version the array.",
    "categories": [
      "math",
      "reducer"
    ],
    "parameters": [
      {
        "name": "data",
        "description": "An array of numbers. An empty array resolves always with `null`.",
        "schema": {
          "type": "array",
          "items": {
            "type": [
              "number",
              "null"
            ]
          }
        }
      },
      {
        "name": "ignore_nodata",
        "description": "Indicates whether no-data values are ignored or not. Ignores them by default. Setting this flag to `false` considers no-data values so that `null` is returned if any value is such a value.",
        "schema": {
          "type": "boolean"
        },
        "default": true,
        "optional": true
      }
    ],
    "returns": {
      "description": "The minimum value.",
      "schema": {
        "type": [
          "number",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "data": [
            1,
            0,
            3,
            2
          ]
        },
        "returns": 0
      },
      {
        "arguments": {
          "data": [
            5,
            2.5,
            null,
            -0.7
          ]
        },
        "returns": -0.7
      },
      {
        "arguments": {
          "data": [
            1,
            0,
            3,
            null,
            2
          ],
          "ignore_nodata": false
        },
        "returns": null
      },
      {
        "arguments": {
          "data": []
        },
        "returns": null
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "http://mathworld.wolfram.com/Minimum.html",
        "title": "Minimum explained by Wolfram MathWorld"
      }
    ]
  },
  {
    "id": "mod",
    "summary": "Modulo",
    "description": "Remainder after division of `x` by `y`.\n\nThe result of a modulo operation has the sign of the divisor. The handling regarding the sign of the result [differs between programming languages](https://en.wikipedia.org/wiki/Modulo_operation) and needs careful consideration while implementing this process.\n\nThe no-data value `null` is passed through and therefore gets propagated if any of the arguments is `null`.",
    "categories": [
      "math"
    ],
    "parameters": [
      {
        "name": "x",
        "description": "A number to be used as dividend.",
        "schema": {
          "type": [
            "number",
            "null"
          ]
        }
      },
      {
        "name": "y",
        "description": "A number to be used as divisor.",
        "schema": {
          "type": [
            "number",
            "null"
          ]
        }
      }
    ],
    "returns": {
      "description": "The remainder after division.",
      "schema": {
        "type": [
          "number",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "x": 27,
          "y": 5
        },
        "returns": 2
      },
      {
        "arguments": {
          "x": -27,
          "y": 5
        },
        "returns": 3
      },
      {
        "arguments": {
          "x": 27,
          "y": -5
        },
        "returns": -3
      },
      {
        "arguments": {
          "x": -27,
          "y": -5
        },
        "returns": -2
      },
      {
        "arguments": {
          "x": 27,
          "y": null
        },
        "returns": null
      },
      {
        "arguments": {
          "x": null,
          "y": 5
        },
        "returns": null
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "https://en.wikipedia.org/wiki/Modulo_operation",
        "title": "Modulo explained by Wikipedia"
      }
    ]
  },
  {
    "id": "multiply",
    "summary": "Multiplication of two numbers",
    "description": "Multiplies the two numbers `x` and `y` (*x * y*) and returns the computed product.\n\nNo-data values are taken into account so that `null` is returned if any element is such a value.\n\nThe computations follow [IEEE Standard 754](https://ieeexplore.ieee.org/document/8766229) whenever the processing environment supports it.",
    "categories": [
      "math"
    ],
    "parameters": [
      {
        "name": "x",
        "description": "The multiplier.",
        "schema": {
          "type": [
            "number",
            "null"
          ]
        }
      },
      {
        "name": "y",
        "description": "The multiplicand.",
        "schema": {
          "type": [
            "number",
            "null"
          ]
        }
      }
    ],
    "returns": {
      "description": "The computed product of the two numbers.",
      "schema": {
        "type": [
          "number",
          "null"
        ]
      }
    },
    "exceptions": {
      "MultiplicandMissing": {
        "message": "Multiplication requires at least two numbers."
      }
    },
    "examples": [
      {
        "arguments": {
          "x": 5,
          "y": 2.5
        },
        "returns": 12.5
      },
      {
        "arguments": {
          "x": -2,
          "y": -4
        },
        "returns": 8
      },
      {
        "arguments": {
          "x": 1,
          "y": null
        },
        "returns": null
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "http://mathworld.wolfram.com/Product.html",
        "title": "Product explained by Wolfram MathWorld"
      },
      {
        "rel": "about",
        "href": "https://ieeexplore.ieee.org/document/8766229",
        "title": "IEEE Standard 754-2019 for Floating-Point Arithmetic"
      }
    ],
    "process_graph": {
      "product": {
        "process_id": "product",
        "arguments": {
          "data": [
            {
              "from_parameter": "x"
            },
            {
              "from_parameter": "y"
            }
          ],
          "ignore_nodata": false
        },
        "result": true
      }
    }
  },
  {
    "id": "ndvi",
    "summary": "Normalized Difference Vegetation Index",
    "description": "Computes the Normalized Difference Vegetation Index (NDVI). The NDVI is computed as *(nir - red) / (nir + red)*.\n\nThe `data` parameter expects a raster data cube with a dimension of type `bands` or a `DimensionAmbiguous` error is thrown otherwise. By default, the dimension must have at least two bands with the common names `red` and `nir` assigned or the user need to specify the parameters `nir` and `red`. Otherwise either the error `NirBandAmbiguous` or `RedBandAmbiguous` is thrown. The common names for each band are specified in the collection's band metadata and are *not* equal to the band names.\n\nBy default, the dimension of type `bands` is dropped by this process. To keep the dimension specify a new band name in the parameter `target_band`. This adds a new dimension label with the specified name to the dimension, which can be used to access the computed values. If a band with the specified name exists, a `BandExists` is thrown.\n\nThis process is very similar to the process ``normalized_difference()``, but determines the bands automatically based on the common names (`red`/`nir`) specified in the metadata.",
    "categories": [
      "math > indices",
      "vegetation indices"
    ],
    "parameters": [
      {
        "name": "data",
        "description": "A raster data cube with two bands that have the common names `red` and `nir` assigned.",
        "schema": {
          "type": "object",
          "subtype": "raster-cube"
        }
      },
      {
        "name": "nir",
        "description": "The name of the NIR band. Defaults to the band that has the common name `nir` assigned.\n\nEither the unique band name (metadata field `name` in bands) or one of the common band names (metadata field `common_name` in bands) can be specified. If unique band name and common name conflict, the unique band name has higher priority.",
        "schema": {
          "type": "string",
          "subtype": "band-name"
        },
        "default": "nir",
        "optional": true
      },
      {
        "name": "red",
        "description": "The name of the red band. Defaults to the band that has the common name `red` assigned.\n\nEither the unique band name (metadata field `name` in bands) or one of the common band names (metadata field `common_name` in bands) can be specified. If unique band name and common name conflict, the unique band name has higher priority.",
        "schema": {
          "type": "string",
          "subtype": "band-name"
        },
        "default": "red",
        "optional": true
      },
      {
        "name": "target_band",
        "description": "By default, the dimension of type `bands` is dropped. To keep the dimension specify a new band name in this parameter so that a new dimension label with the specified name will be added for the computed values.",
        "schema": [
          {
            "type": "string",
            "pattern": "^\\w+$"
          },
          {
            "type": "null"
          }
        ],
        "default": null,
        "optional": true
      }
    ],
    "returns": {
      "description": "A raster data cube containing the computed NDVI values.",
      "schema": {
        "type": "object",
        "subtype": "raster-cube"
      }
    },
    "exceptions": {
      "NirBandAmbiguous": {
        "message": "The NIR band can't be resolved, please specify a band name."
      },
      "RedBandAmbiguous": {
        "message": "The red band can't be resolved, please specify a band name."
      },
      "DimensionAmbiguous": {
        "message": "dimension of type `bands` is not available or is ambiguous.."
      },
      "BandExists": {
        "message": "A band with the specified target name exists."
      }
    },
    "links": [
      {
        "rel": "about",
        "href": "https://en.wikipedia.org/wiki/Normalized_difference_vegetation_index",
        "title": "NDVI explained by Wikipedia"
      },
      {
        "rel": "about",
        "href": "https://earthobservatory.nasa.gov/features/MeasuringVegetation/measuring_vegetation_2.php",
        "title": "NDVI explained by NASA"
      },
      {
        "rel": "about",
        "href": "https://github.com/radiantearth/stac-spec/tree/master/extensions/eo#common-band-names",
        "title": "List of common band names as specified by the STAC specification"
      }
    ]
  },
  {
    "id": "neq",
    "summary": "Not equal to comparison",
    "description": "Compares whether `x` is *not* strictly equal to `y`.\n\n**Remarks:**\n\n* Data types MUST be checked strictly, for example a string with the content *1* is not equal to the number *1*. Nevertheless, an integer *1* is equal to a floating point number *1.0* as `integer` is a sub-type of `number`.\n* If any operand is `null`, the return value is `null`. Therefore, `neq(null, null)` returns `null` instead of `false`.\n* If any operand is an array or object, the return value is `false`.\n* Strings are expected to be encoded in UTF-8 by default.\n* Temporal strings MUST be compared differently than other strings and MUST NOT be compared based on their string representation due to different possible representations. For example, the UTC time zone representation `Z` has the same meaning as `+00:00`.",
    "categories": [
      "texts",
      "comparison"
    ],
    "parameters": [
      {
        "name": "x",
        "description": "First operand.",
        "schema": {
          "description": "Any data type is allowed."
        }
      },
      {
        "name": "y",
        "description": "Second operand.",
        "schema": {
          "description": "Any data type is allowed."
        }
      },
      {
        "name": "delta",
        "description": "Only applicable for comparing two numbers. If this optional parameter is set to a positive non-zero number the non-equality of two numbers is checked against a delta value. This is especially useful to circumvent problems with floating point inaccuracy in machine-based computation.\n\nThis option is basically an alias for the following computation: `gt(abs(minus([x, y]), delta)`",
        "schema": {
          "type": [
            "number",
            "null"
          ]
        },
        "default": null,
        "optional": true
      },
      {
        "name": "case_sensitive",
        "description": "Only applicable for comparing two strings. Case sensitive comparison can be disabled by setting this parameter to `false`.",
        "schema": {
          "type": "boolean"
        },
        "default": true,
        "optional": true
      }
    ],
    "returns": {
      "description": "Returns `true` if `x` is *not* equal to `y`, `null` if any operand is `null`, otherwise `false`.",
      "schema": {
        "type": [
          "boolean",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "x": 1,
          "y": null
        },
        "returns": null
      },
      {
        "arguments": {
          "x": 1,
          "y": 1
        },
        "returns": false
      },
      {
        "arguments": {
          "x": 1,
          "y": "1"
        },
        "returns": true
      },
      {
        "arguments": {
          "x": 0,
          "y": false
        },
        "returns": true
      },
      {
        "arguments": {
          "x": 1.02,
          "y": 1,
          "delta": 0.01
        },
        "returns": true
      },
      {
        "arguments": {
          "x": -1,
          "y": -1.001,
          "delta": 0.01
        },
        "returns": false
      },
      {
        "arguments": {
          "x": 115,
          "y": 110,
          "delta": 10
        },
        "returns": false
      },
      {
        "arguments": {
          "x": "Test",
          "y": "test"
        },
        "returns": true
      },
      {
        "arguments": {
          "x": "Test",
          "y": "test",
          "case_sensitive": false
        },
        "returns": false
      },
      {
        "arguments": {
          "x": "",
          "y": "",
          "case_sensitive": false
        },
        "returns": false
      },
      {
        "arguments": {
          "x": "00:00:00+00:00",
          "y": "00:00:00Z"
        },
        "returns": false
      },
      {
        "description": "`y` is not a valid date-time representation and therefore will be treated as a string so that the provided values are not equal.",
        "arguments": {
          "x": "2018-01-01T12:00:00Z",
          "y": "2018-01-01T12:00:00"
        },
        "returns": true
      },
      {
        "description": "01:00 in the time zone +1 is equal to 00:00 in UTC.",
        "arguments": {
          "x": "2018-01-01T00:00:00Z",
          "y": "2018-01-01T01:00:00+01:00"
        },
        "returns": false
      },
      {
        "arguments": {
          "x": [
            1,
            2,
            3
          ],
          "y": [
            1,
            2,
            3
          ]
        },
        "returns": false
      }
    ],
    "process_graph": {
      "eq": {
        "process_id": "eq",
        "arguments": {
          "x": {
            "from_parameter": "x"
          },
          "y": {
            "from_parameter": "y"
          },
          "delta": {
            "from_parameter": "delta"
          },
          "case_sensitive": {
            "from_parameter": "case_sensitive"
          }
        }
      },
      "not": {
        "process_id": "not",
        "arguments": {
          "x": {
            "from_node": "eq"
          }
        },
        "result": true
      }
    }
  },
  {
    "id": "normalized_difference",
    "summary": "Normalized difference",
    "description": "Computes the normalized difference for two bands. The normalized difference is computed as *(x - y) / (x + y)*.\n\nThis process could be used for a number of remote sensing indices such as:\n\n* [NDVI](https://eos.com/ndvi/): `x` = NIR band, `y` = red band\n* [NDWI](https://eos.com/ndwi/): `x` = NIR band, `y` = SWIR band\n* [NDSI](https://eos.com/ndsi/): `x` = green band, `y` = SWIR band\n\nSome back-ends may have native processes such as ``ndvi()`` available for convenience.",
    "categories": [
      "math > indices",
      "vegetation indices"
    ],
    "parameters": [
      {
        "name": "x",
        "description": "The value for the first band.",
        "schema": {
          "type": "number"
        }
      },
      {
        "name": "y",
        "description": "The value for the second band.",
        "schema": {
          "type": "number"
        }
      }
    ],
    "returns": {
      "description": "The computed normalized difference.",
      "schema": {
        "type": "number",
        "minimum": -1,
        "maximum": 1
      }
    },
    "links": [
      {
        "rel": "related",
        "href": "https://eos.com/ndvi/",
        "title": "NDVI explained by EOS"
      },
      {
        "rel": "related",
        "href": "https://eos.com/ndwi/",
        "title": "NDWI explained by EOS"
      },
      {
        "rel": "related",
        "href": "https://eos.com/ndsi/",
        "title": "NDSI explained by EOS"
      }
    ],
    "process_graph": {
      "subtract": {
        "process_id": "subtract",
        "arguments": {
          "x": {
            "from_parameter": "x"
          },
          "y": {
            "from_parameter": "y"
          }
        }
      },
      "add": {
        "process_id": "add",
        "arguments": {
          "x": {
            "from_parameter": "x"
          },
          "y": {
            "from_parameter": "y"
          }
        }
      },
      "divide": {
        "process_id": "divide",
        "arguments": {
          "x": {
            "from_node": "subtract"
          },
          "y": {
            "from_node": "add"
          }
        },
        "result": true
      }
    }
  },
  {
    "id": "not",
    "summary": "Inverting a boolean",
    "description": "Inverts a single boolean so that `true` gets `false` and `false` gets `true`.\n\nThe no-data value `null` is passed through and therefore gets propagated.",
    "categories": [
      "logic"
    ],
    "parameters": [
      {
        "name": "x",
        "description": "Boolean value to invert.",
        "schema": {
          "type": [
            "boolean",
            "null"
          ]
        }
      }
    ],
    "returns": {
      "description": "Inverted boolean value.",
      "schema": {
        "type": [
          "boolean",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "x": null
        },
        "returns": null
      },
      {
        "arguments": {
          "x": false
        },
        "returns": true
      },
      {
        "arguments": {
          "x": true
        },
        "returns": false
      }
    ]
  },
  {
    "id": "or",
    "summary": "Logical OR",
    "description": "Checks if **at least one** of the values is true. Evaluates parameter `x` before `y` and stops once the outcome is unambiguous. If a component is `null`, the result will be `null` if the outcome is ambiguous.\n\n**Truth table:**\n\n```\na \\ b || null | false | true\n----- || ---- | ----- | ----\nnull  || null | null  | true\nfalse || null | false | true\ntrue  || true | true  | true\n```",
    "categories": [
      "logic"
    ],
    "parameters": [
      {
        "name": "x",
        "description": "A boolean value.",
        "schema": {
          "type": [
            "boolean",
            "null"
          ]
        }
      },
      {
        "name": "y",
        "description": "A boolean value.",
        "schema": {
          "type": [
            "boolean",
            "null"
          ]
        }
      }
    ],
    "returns": {
      "description": "Boolean result of the logical OR.",
      "schema": {
        "type": [
          "boolean",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "x": true,
          "y": true
        },
        "returns": true
      },
      {
        "arguments": {
          "x": false,
          "y": false
        },
        "returns": false
      },
      {
        "arguments": {
          "x": true,
          "y": null
        },
        "returns": true
      },
      {
        "arguments": {
          "x": null,
          "y": true
        },
        "returns": true
      },
      {
        "arguments": {
          "x": false,
          "y": null
        },
        "returns": null
      }
    ],
    "process_graph": {
      "any": {
        "process_id": "any",
        "arguments": {
          "data": [
            {
              "from_parameter": "x"
            },
            {
              "from_parameter": "y"
            }
          ],
          "ignore_nodata": false
        },
        "result": true
      }
    }
  },
  {
    "id": "order",
    "summary": "Create a permutation",
    "description": "Computes a permutation which allows rearranging the data into ascending or descending order. In other words, this process computes the ranked (sorted) element positions in the original list.\n\n**Remarks:**\n\n* The positions in the result are zero-based.\n* Ties will be left in their original ordering.\n* Temporal strings can *not* be compared based on their string representation due to the time zone / time-offset representations.",
    "categories": [
      "arrays",
      "sorting"
    ],
    "parameters": [
      {
        "name": "data",
        "description": "An array to compute the order for.",
        "schema": {
          "type": "array",
          "items": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "null"
              },
              {
                "type": "string",
                "format": "date-time",
                "subtype": "date-time"
              },
              {
                "type": "string",
                "format": "date",
                "subtype": "date"
              },
              {
                "type": "string",
                "format": "time",
                "subtype": "time"
              }
            ]
          }
        }
      },
      {
        "name": "asc",
        "description": "The default sort order is ascending, with smallest values first. To sort in reverse (descending) order, set this parameter to `false`.",
        "schema": {
          "type": "boolean"
        },
        "default": true,
        "optional": true
      },
      {
        "name": "nodata",
        "description": "Controls the handling of no-data values (`null`). By default they are removed. If `true`, missing values in the data are put last; if `false`, they are put first.",
        "schema": {
          "type": [
            "boolean",
            "null"
          ]
        },
        "default": null,
        "optional": true
      }
    ],
    "returns": {
      "description": "The computed permutation.",
      "schema": {
        "type": "array",
        "items": {
          "type": "integer",
          "minimum": 0
        }
      }
    },
    "examples": [
      {
        "arguments": {
          "data": [
            6,
            -1,
            2,
            null,
            7,
            4,
            null,
            8,
            3,
            9,
            9
          ]
        },
        "returns": [
          1,
          2,
          8,
          5,
          0,
          4,
          7,
          9,
          10
        ]
      },
      {
        "arguments": {
          "data": [
            6,
            -1,
            2,
            null,
            7,
            4,
            null,
            8,
            3,
            9,
            9
          ],
          "nodata": true
        },
        "returns": [
          1,
          2,
          8,
          5,
          0,
          4,
          7,
          9,
          10,
          3,
          6
        ]
      },
      {
        "arguments": {
          "data": [
            6,
            -1,
            2,
            null,
            7,
            4,
            null,
            8,
            3,
            9,
            9
          ],
          "asc": false,
          "nodata": true
        },
        "returns": [
          9,
          10,
          7,
          4,
          0,
          5,
          8,
          2,
          1,
          3,
          6
        ]
      },
      {
        "arguments": {
          "data": [
            6,
            -1,
            2,
            null,
            7,
            4,
            null,
            8,
            3,
            9,
            9
          ],
          "asc": false,
          "nodata": false
        },
        "returns": [
          3,
          6,
          9,
          10,
          7,
          4,
          0,
          5,
          8,
          2,
          1
        ]
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "http://mathworld.wolfram.com/Permutation.html",
        "title": "Permutation explained by Wolfram MathWorld"
      }
    ]
  },
  {
    "id": "pi",
    "summary": "Pi ()",
    "description": "The real number Pi () is a mathematical constant that is the ratio of the circumference of a circle to its diameter. The numerical value is approximately *3.14159*.",
    "categories": [
      "math > constants",
      "math > trigonometric"
    ],
    "parameters": [],
    "returns": {
      "description": "The numerical value of Pi.",
      "schema": {
        "type": "number"
      }
    },
    "examples": [
      {
        "title": "Test for sin() = 0",
        "process_graph": {
          "pi1": {
            "process_id": "pi",
            "arguments": {}
          },
          "sin1": {
            "process_id": "sin",
            "arguments": {
              "data": {
                "from_node": "pi1"
              }
            },
            "result": true
          }
        },
        "returns": 0
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "http://mathworld.wolfram.com/Pi.html",
        "title": "Mathematical constant Pi explained by Wolfram MathWorld"
      }
    ]
  },
  {
    "id": "power",
    "summary": "Exponentiation",
    "description": "Computes the exponentiation for the base `base` raised to the power of `p`.\n\nThe no-data value `null` is passed through and therefore gets propagated if any of the arguments is `null`.",
    "categories": [
      "math",
      "math > exponential & logarithmic"
    ],
    "parameters": [
      {
        "name": "base",
        "description": "The numerical base.",
        "schema": {
          "type": [
            "number",
            "null"
          ]
        }
      },
      {
        "name": "p",
        "description": "The numerical exponent.",
        "schema": {
          "type": [
            "number",
            "null"
          ]
        }
      }
    ],
    "returns": {
      "description": "The computed value for `base` raised to the power of `p`.",
      "schema": {
        "type": [
          "number",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "base": 0,
          "p": 2
        },
        "returns": 0
      },
      {
        "arguments": {
          "base": 2.5,
          "p": 0
        },
        "returns": 1
      },
      {
        "arguments": {
          "base": 3,
          "p": 3
        },
        "returns": 27
      },
      {
        "arguments": {
          "base": 5,
          "p": -1
        },
        "returns": 0.2
      },
      {
        "arguments": {
          "base": 1,
          "p": 0.5
        },
        "returns": 1
      },
      {
        "arguments": {
          "base": 1,
          "p": null
        },
        "returns": null
      },
      {
        "arguments": {
          "base": null,
          "p": 2
        },
        "returns": null
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "http://mathworld.wolfram.com/Power.html",
        "title": "Power explained by Wolfram MathWorld"
      }
    ]
  },
  {
    "id": "product",
    "summary": "Compute the product by multiplying numbers",
    "description": "Multiplies all elements in a sequential array of numbers and returns the computed product.\n\nBy default no-data values are ignored. Setting `ignore_nodata` to `false` considers no-data values so that `null` is returned if any element is such a value.\n\nThe computations follow [IEEE Standard 754](https://ieeexplore.ieee.org/document/8766229) whenever the processing environment supports it.",
    "categories": [
      "math",
      "reducer"
    ],
    "parameters": [
      {
        "name": "data",
        "description": "An array of numbers.",
        "schema": {
          "type": "array",
          "items": {
            "type": [
              "number",
              "null"
            ]
          }
        }
      },
      {
        "name": "ignore_nodata",
        "description": "Indicates whether no-data values are ignored or not. Ignores them by default. Setting this flag to `false` considers no-data values so that `null` is returned if any value is such a value.",
        "schema": {
          "type": "boolean"
        },
        "default": true,
        "optional": true
      }
    ],
    "returns": {
      "description": "The computed product of the sequence of numbers.",
      "schema": {
        "type": [
          "number",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "data": [
            5,
            0
          ]
        },
        "returns": 0
      },
      {
        "arguments": {
          "data": [
            -2,
            4,
            2.5
          ]
        },
        "returns": -20
      },
      {
        "arguments": {
          "data": [
            1,
            null
          ],
          "ignore_nodata": false
        },
        "returns": null
      },
      {
        "arguments": {
          "data": [
            -1
          ]
        },
        "returns": -1
      },
      {
        "arguments": {
          "data": [
            null
          ],
          "ignore_nodata": false
        },
        "returns": null
      },
      {
        "arguments": {
          "data": []
        },
        "returns": null
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "http://mathworld.wolfram.com/Product.html",
        "title": "Product explained by Wolfram MathWorld"
      },
      {
        "rel": "about",
        "href": "https://ieeexplore.ieee.org/document/8766229",
        "title": "IEEE Standard 754-2019 for Floating-Point Arithmetic"
      }
    ]
  },
  {
    "id": "quantiles",
    "summary": "Quantiles",
    "description": "Calculates quantiles, which are cut points dividing the range of a probability distribution into either\n\n* intervals corresponding to the given `probabilities` or\n* (nearly) equal-sized intervals (q-quantiles based on the parameter `q`).\n\nEither the parameter `probabilites` or `q` must be specified, otherwise the `QuantilesParameterMissing` exception is thrown. If both parameters are set the `QuantilesParameterConflict` exception is thrown.",
    "categories": [
      "math"
    ],
    "parameters": [
      {
        "name": "data",
        "description": "An array of numbers.",
        "schema": {
          "type": "array",
          "items": {
            "type": [
              "number",
              "null"
            ]
          }
        }
      },
      {
        "name": "probabilities",
        "description": "A list of probabilities to calculate quantiles for. The probabilities must be between 0 and 1.",
        "schema": {
          "type": "array",
          "items": {
            "type": "number",
            "minimum": 0,
            "maximum": 1
          }
        },
        "optional": true
      },
      {
        "name": "q",
        "description": "A number of intervals to calculate quantiles for. Calculates q-quantiles with (nearly) equal-sized intervals.",
        "schema": {
          "type": "integer",
          "minimum": 2
        },
        "optional": true
      },
      {
        "name": "ignore_nodata",
        "description": "Indicates whether no-data values are ignored or not. Ignores them by default. Setting this flag to `false` considers no-data values so that an array with `null` values is returned if any element is such a value.",
        "schema": {
          "type": "boolean"
        },
        "default": true,
        "optional": true
      }
    ],
    "returns": {
      "description": "An array with the computed quantiles. The list has either\n\n* as many elements as the given list of `probabilities` had or\n* *`q`-1* elements.\n\nIf the input array is empty the resulting array is filled with as many `null` values as required according to the list above. For an example, see the 'Empty array example'.",
      "schema": {
        "type": "array",
        "items": {
          "type": [
            "number",
            "null"
          ]
        }
      }
    },
    "exceptions": {
      "QuantilesParameterMissing": {
        "message": "The process 'quantiles' requires either the 'probabilities' or 'q' parameter to be set."
      },
      "QuantilesParameterConflict": {
        "message": "The process 'quantiles' only allows that either the 'probabilities' or the 'q' parameter is set."
      }
    },
    "examples": [
      {
        "arguments": {
          "data": [
            2,
            4,
            4,
            4,
            5,
            5,
            7,
            9
          ],
          "probabilities": [
            0.005,
            0.01,
            0.02,
            0.05,
            0.1,
            0.5
          ]
        },
        "returns": [
          2.07,
          2.14,
          2.28,
          2.7,
          3.4,
          4.5
        ]
      },
      {
        "arguments": {
          "data": [
            2,
            4,
            4,
            4,
            5,
            5,
            7,
            9
          ],
          "q": 4
        },
        "returns": [
          4,
          4.5,
          5.5
        ]
      },
      {
        "arguments": {
          "data": [
            -1,
            -0.5,
            null,
            1
          ],
          "q": 2
        },
        "returns": [
          -0.5
        ]
      },
      {
        "arguments": {
          "data": [
            -1,
            -0.5,
            null,
            1
          ],
          "q": 4,
          "ignore_nodata": false
        },
        "returns": [
          null,
          null,
          null
        ]
      },
      {
        "title": "Empty array example",
        "arguments": {
          "data": [],
          "probabilities": [
            0.1,
            0.5
          ]
        },
        "returns": [
          null,
          null
        ]
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "https://en.wikipedia.org/wiki/Quantile",
        "title": "Quantiles explained by Wikipedia"
      }
    ]
  },
  {
    "id": "rearrange",
    "summary": "Rearrange an array based on a permutation",
    "description": "Rearranges an array based on a permutation, i.e. a ranked list of element positions in the original list. The positions must be zero-based.",
    "categories": [
      "arrays",
      "sorting"
    ],
    "parameters": [
      {
        "name": "data",
        "description": "The array to rearrange.",
        "schema": {
          "type": "array",
          "items": {
            "description": "Any data type is allowed."
          }
        }
      },
      {
        "name": "order",
        "description": "The permutation used for rearranging.",
        "schema": {
          "type": "array",
          "items": {
            "type": "integer",
            "minimum": 0
          }
        }
      }
    ],
    "returns": {
      "description": "The rearranged array.",
      "schema": {
        "type": "array",
        "items": {
          "description": "Any data type is allowed."
        }
      }
    },
    "examples": [
      {
        "title": "Reverse a list",
        "arguments": {
          "data": [
            5,
            4,
            3
          ],
          "order": [
            2,
            1,
            0
          ]
        },
        "returns": [
          3,
          4,
          5
        ]
      },
      {
        "title": "Remove two elements",
        "arguments": {
          "data": [
            5,
            4,
            3,
            2
          ],
          "order": [
            1,
            3
          ]
        },
        "returns": [
          4,
          2
        ]
      },
      {
        "title": "Swap two elements",
        "arguments": {
          "data": [
            5,
            4,
            3,
            2
          ],
          "order": [
            0,
            2,
            1,
            3
          ]
        },
        "returns": [
          5,
          3,
          4,
          2
        ]
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "http://mathworld.wolfram.com/Permutation.html",
        "title": "Permutation explained by Wolfram MathWorld"
      }
    ]
  },
  {
    "id": "reduce_dimension_binary",
    "summary": "Reduce dimensions using binary reduction",
    "description": "Applies a binary reducer to a data cube dimension by collapsing all the pixel values along the specified dimension into an output value computed by the reducer. This process consecutively passes a pair of values to the reducer. This may be better suited especially for UDFs in case the number of values gets too large to be processed at once. In contrast, ``reduce_dimension()`` passes a list of values.\n\nThe dimension is dropped. To avoid this, use ``apply_dimension()`` instead.",
    "categories": [
      "cubes",
      "reducer"
    ],
    "experimental": true,
    "parameters": [
      {
        "name": "data",
        "description": "A data cube.",
        "schema": {
          "type": "object",
          "subtype": "raster-cube"
        }
      },
      {
        "name": "reducer",
        "description": "A reduction operator to be applied consecutively on pairs of values. It must be both associative and commutative as the execution may be executed in parallel and therefore the order of execution is arbitrary. The reduction operator may be a single process such as ``multiply()`` or consist of multiple sub-processes.",
        "schema": {
          "type": "object",
          "subtype": "process-graph",
          "parameters": [
            {
              "name": "x",
              "description": "The first value.",
              "schema": {
                "description": "Any data type."
              }
            },
            {
              "name": "y",
              "description": "The second value.",
              "schema": {
                "description": "Any data type."
              }
            },
            {
              "name": "context",
              "description": "Additional data passed by the user.",
              "schema": {
                "description": "Any data type."
              },
              "optional": true,
              "default": null
            }
          ]
        }
      },
      {
        "name": "dimension",
        "description": "The name of the dimension over which to reduce. Fails with a `DimensionNotAvailable` error if the specified dimension does not exist.\n\n**Remarks:**\n\n* The default dimensions a data cube provides are described in the collection's metadata field `cube:dimensions`.\n* There could be multiple spatial dimensions such as `x`, `y` or `z`.\n* For multi-spectral imagery there is usually a separate dimension of type `bands` for the bands.",
        "schema": {
          "type": "string"
        }
      },
      {
        "name": "context",
        "description": "Additional data to be passed to the reducer.",
        "schema": {
          "description": "Any data type."
        },
        "optional": true,
        "default": null
      }
    ],
    "returns": {
      "description": "A data cube with the newly computed values. It has one dimension less than the original data cube, but the remaining dimensions have their resolution and cardinality preserved.",
      "schema": {
        "type": "object",
        "subtype": "raster-cube"
      }
    },
    "exceptions": {
      "DimensionNotAvailable": {
        "message": "A dimension with the specified name does not exist."
      }
    },
    "links": [
      {
        "rel": "about",
        "href": "https://en.wikipedia.org/wiki/Reduction_Operator",
        "title": "Background information on reduction operators (binary reducers) by Wikipedia"
      }
    ]
  },
  {
    "id": "reduce_dimension",
    "summary": "Reduce dimensions",
    "description": "Applies a unary reducer to a data cube dimension by collapsing all the pixel values along the specified dimension into an output value computed by the reducer. This process passes a list of values to the reducer. In contrast, ``reduce_dimension_binary()`` passes two values, which may be better suited especially for UDFs in case the number of values gets too large to be processed at once.\n\nThe dimension is dropped. To avoid this, use ``apply_dimension()`` instead.",
    "categories": [
      "cubes",
      "reducer"
    ],
    "parameters": [
      {
        "name": "data",
        "description": "A data cube.",
        "schema": {
          "type": "object",
          "subtype": "raster-cube"
        }
      },
      {
        "name": "reducer",
        "description": "A reducer to apply on the specified dimension. A reducer is a single process such as ``mean()`` or a set of processes, which computes a single value for a list of values, see the category 'reducer' for such processes.",
        "schema": {
          "type": "object",
          "subtype": "process-graph",
          "parameters": [
            {
              "name": "data",
              "description": "A labeled array with elements of any type.",
              "schema": {
                "type": "array",
                "subtype": "labeled-array",
                "items": {
                  "description": "Any data type."
                }
              }
            },
            {
              "name": "context",
              "description": "Additional data passed by the user.",
              "schema": {
                "description": "Any data type."
              },
              "optional": true,
              "default": null
            }
          ]
        }
      },
      {
        "name": "dimension",
        "description": "The name of the dimension over which to reduce. Fails with a `DimensionNotAvailable` error if the specified dimension does not exist.\n\n**Remarks:**\n\n* The default dimensions a data cube provides are described in the collection's metadata field `cube:dimensions`.\n* There could be multiple spatial dimensions such as `x`, `y` or `z`.\n* For multi-spectral imagery there is usually a separate dimension of type `bands` for the bands.",
        "schema": {
          "type": "string"
        }
      },
      {
        "name": "context",
        "description": "Additional data to be passed to the reducer.",
        "schema": {
          "description": "Any data type."
        },
        "optional": true,
        "default": null
      }
    ],
    "returns": {
      "description": "A data cube with the newly computed values. It has one dimension less than the original data cube, but the remaining dimensions have their resolution and cardinality preserved.",
      "schema": {
        "type": "object",
        "subtype": "raster-cube"
      }
    },
    "exceptions": {
      "DimensionNotAvailable": {
        "message": "A dimension with the specified name does not exist."
      }
    }
  },
  {
    "id": "rename_dimension",
    "summary": "Rename a dimension",
    "description": "Renames a dimension in the data cube while preserving all other properties.",
    "categories": [
      "cubes"
    ],
    "parameters": [
      {
        "name": "data",
        "description": "The data cube.",
        "schema": {
          "type": "object",
          "subtype": "raster-cube"
        }
      },
      {
        "name": "source",
        "description": "The current name of the dimension. Fails with a `DimensionNotAvailable` error if the specified dimension does not exist.",
        "schema": {
          "type": "string"
        }
      },
      {
        "name": "target",
        "description": "A new Name for the dimension. Fails with a `DimensionExists` error if a dimension with the specified name exists.",
        "schema": {
          "type": "string"
        }
      }
    ],
    "returns": {
      "description": "The data cube with the renamed dimension. The old name can not be referenced any longer.",
      "schema": {
        "type": "object",
        "subtype": "raster-cube"
      }
    },
    "exceptions": {
      "DimensionNotAvailable": {
        "message": "A dimension with the specified name does not exist."
      },
      "DimensionExists": {
        "message": "A dimension with the specified name already exists."
      }
    }
  },
  {
    "id": "rename_labels",
    "summary": "Rename dimension labels",
    "description": "Renames the labels of the specified dimension in the data cube from `source` to `target`.\n\nIf the array for the source labels is empty (the default), the dimension labels are expected to be enumerated with zero-based numbering (0,1,2,3,...) so that the dimension labels directly map to the indices of the array specified for the parameter `target`. If the dimension labels are not enumerated and the `target` parameter is not specified, a `LabelsNotEnumerated` is thrown. The number of source and target labels must be equal, otherwise the error `LabelMismatch` is thrown.\n\nThis process doesn't change the order of the labels and their corresponding data.",
    "categories": [
      "cubes"
    ],
    "parameters": [
      {
        "name": "data",
        "description": "The data cube.",
        "schema": {
          "type": "object",
          "subtype": "raster-cube"
        }
      },
      {
        "name": "dimension",
        "description": "The name of the dimension to rename the labels for.",
        "schema": {
          "type": "string"
        }
      },
      {
        "name": "target",
        "description": "The new names for the labels. The dimension labels in the data cube are expected to be enumerated, if the parameter `target` is not specified. If a target dimension label already exists in the data cube, a `LabelExists` error is thrown.",
        "schema": {
          "type": "array",
          "items": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "string"
              }
            ]
          }
        }
      },
      {
        "name": "source",
        "description": "The names of the labels as they are currently in the data cube. The array defines an unsorted and potentially incomplete list of labels that should be renamed to the names available in the corresponding array elements in the parameter `target`. If one of the source dimension labels doesn't exist, a `LabelNotAvailable` error is thrown. By default, the array is empty so that the dimension labels in the data cube are expected to be enumerated.",
        "schema": {
          "type": "array",
          "items": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "string"
              }
            ]
          }
        },
        "default": [],
        "optional": true
      }
    ],
    "returns": {
      "description": "The data cube with the renamed labels. The old labels can not be referenced any longer.",
      "schema": {
        "type": "object",
        "subtype": "raster-cube"
      }
    },
    "exceptions": {
      "LabelsNotEnumerated": {
        "message": "The dimension labels are not enumerated."
      },
      "LabelMismatch": {
        "message": "The number of labels in the parameters `source` and `target` don't match."
      },
      "LabelNotAvailable": {
        "message": "A label with the specified name does not exist."
      },
      "LabelExists": {
        "message": "A label with the specified name exists."
      }
    },
    "examples": [
      {
        "title": "Rename named labels",
        "description": "Renaming the bands from `B1` to `red`, from `B2` to `green` and from `B3` to `blue`. Doesn't rename the band `QA`.",
        "process_graph": {
          "loadco1": {
            "process_id": "load_collection",
            "arguments": {
              "id": "S2-RGB",
              "spatial_extent": null,
              "temporal_extent": null,
              "bands": [
                "B1",
                "B2",
                "B3",
                "QA"
              ]
            }
          },
          "rename1": {
            "process_id": "rename_labels",
            "arguments": {
              "data": {
                "from_node": "loadco1"
              },
              "dimension": "bands",
              "source": [
                "B1",
                "B2",
                "B3"
              ],
              "target": [
                "red",
                "green",
                "blue"
              ]
            },
            "result": true
          }
        }
      },
      {
        "title": "Rename enumerated labels",
        "description": "The process replaces the temporal dimension with a new dimension `min_max` with enumerated labels. The first label refers to the minimum values, the second label refers to the maximum values. Afterwards, the dimension labels are renamed to `min` and `max` respectively.",
        "process_graph": {
          "loadco1": {
            "process_id": "load_collection",
            "arguments": {
              "id": "S2-RGB",
              "spatial_extent": null,
              "temporal_extent": null
            }
          },
          "apply1": {
            "process_id": "apply_dimension",
            "arguments": {
              "data": {
                "from_node": "loadco1"
              },
              "process": {
                "process_graph": {
                  "extrem1": {
                    "process_id": "extrema",
                    "arguments": {
                      "data": {
                        "from_parameter": "data"
                      }
                    },
                    "result": true
                  }
                }
              },
              "dimension": "t",
              "target_dimension": "min_max"
            }
          },
          "rename1": {
            "process_id": "rename_labels",
            "arguments": {
              "data": {
                "from_node": "apply1"
              },
              "dimension": "bands",
              "target": [
                "min",
                "max"
              ]
            },
            "result": true
          }
        }
      }
    ]
  },
  {
    "id": "resample_cube_spatial",
    "summary": "Resample the spatial dimensions to match a target data cube",
    "description": "Resamples the spatial dimensions (x,y) from a source data cube to align with the corresponding dimensions of the given target data cube. Returns a new data cube with the resampled dimensions.\n\nTo resample a data cube to a specific resolution or projection regardless of an existing target data cube, refer to ``resample_spatial()``.",
    "categories": [
      "cubes",
      "aggregate & resample"
    ],
    "parameters": [
      {
        "name": "data",
        "description": "A data cube.",
        "schema": {
          "type": "object",
          "subtype": "raster-cube"
        }
      },
      {
        "name": "target",
        "description": "A data cube that describes the spatial target resolution.",
        "schema": {
          "type": "object",
          "subtype": "raster-cube"
        }
      },
      {
        "name": "method",
        "description": "Resampling method. Methods are inspired by GDAL, see [gdalwarp](https://www.gdal.org/gdalwarp.html) for more information.",
        "schema": {
          "type": "string",
          "enum": [
            "near",
            "bilinear",
            "cubic",
            "cubicspline",
            "lanczos",
            "average",
            "mode",
            "max",
            "min",
            "med",
            "q1",
            "q3"
          ]
        },
        "default": "near",
        "optional": true
      }
    ],
    "returns": {
      "description": "A data cube with potentially lower spatial resolution and potentially lower cardinality, but the same number of dimensions as the original data cube.",
      "schema": {
        "type": "object",
        "subtype": "raster-cube"
      }
    },
    "links": [
      {
        "href": "https://open-eo.github.io/openeo-api/glossary/#aggregation-and-resampling",
        "rel": "about",
        "title": "Resampling explained in the openEO glossary"
      }
    ]
  },
  {
    "id": "resample_cube_temporal",
    "summary": "Resample a temporal dimension to match a target data cube",
    "description": "Resamples the given temporal dimension from a source data cube to align with the corresponding dimension of the given target data cube. Returns a new data cube with the resampled dimension.\n\nIf the dimension is not set or is set to `null`, the data cube is expected to have one temporal dimension only.",
    "categories": [
      "cubes",
      "aggregate & resample"
    ],
    "parameters": [
      {
        "name": "data",
        "description": "A data cube.",
        "schema": {
          "type": "object",
          "subtype": "raster-cube"
        }
      },
      {
        "name": "target",
        "description": "A data cube that describes the temporal target resolution.",
        "schema": {
          "type": "object",
          "subtype": "raster-cube"
        }
      },
      {
        "name": "method",
        "description": "A resampling method to be applied, could be a reducer for downsampling or other methods for upsampling. A reducer is a single process such as ``mean()`` or a set of processes, which computes a single value for a list of values, see the category 'reducer' for such processes.",
        "schema": {
          "type": "object",
          "subtype": "process-graph",
          "parameters": [
            {
              "name": "data",
              "description": "A labeled array with elements of any type.",
              "schema": {
                "type": "array",
                "subtype": "labeled-array",
                "items": {
                  "description": "Any data type."
                }
              }
            },
            {
              "name": "context",
              "description": "Additional data passed by the user.",
              "schema": {
                "description": "Any data type."
              },
              "optional": true,
              "default": null
            }
          ]
        }
      },
      {
        "name": "dimension",
        "description": "The name of the temporal dimension to resample, which must exist with this name in both data cubes. If the dimension is not set or is set to `null`, the data cube is expected to only have one temporal dimension. Fails with a `TooManyDimensions` error if it has more dimensions. Fails with a `DimensionNotAvailable` error if the specified dimension does not exist.\n\n**Note:** The default dimensions a data cube provides are described in the collection's metadata field `cube:dimensions`.",
        "schema": {
          "type": [
            "string",
            "null"
          ]
        },
        "default": null,
        "optional": true
      },
      {
        "name": "context",
        "description": "Additional data to be passed to the process specified for the parameter `method`.",
        "schema": {
          "description": "Any data type."
        },
        "optional": true,
        "default": null
      }
    ],
    "returns": {
      "description": "A data cube with potentially lower temporal resolution and potentially lower cardinality, but the same number of dimensions as the original data cube.",
      "schema": {
        "type": "object",
        "subtype": "raster-cube"
      }
    },
    "exceptions": {
      "TooManyDimensions": {
        "message": "The number of temporal dimensions must be reduced to one for 'resample_cube_temporal'."
      },
      "DimensionNotAvailable": {
        "message": "A dimension with the specified name does not exist."
      }
    },
    "links": [
      {
        "href": "https://open-eo.github.io/openeo-api/glossary/#aggregation-and-resampling",
        "rel": "about",
        "title": "Resampling explained in the openEO glossary"
      }
    ]
  },
  {
    "id": "resample_spatial",
    "summary": "Resample and warp the spatial dimensions",
    "description": "Resamples the spatial dimensions (x,y) of the data cube to a specified resolution and/or warps the data cube to the target projection. At least `resolution` or `projection` must be specified.\n\nRelated processes:\n\n* Use ``filter_bbox()`` to set the target spatial extent.\n* To spatially align two data cubes with each other (e.g. for merging), better use the process ``resample_cube_spatial()``.",
    "categories": [
      "cubes",
      "aggregate & resample"
    ],
    "parameters": [
      {
        "name": "data",
        "description": "A raster data cube.",
        "schema": {
          "type": "object",
          "subtype": "raster-cube"
        }
      },
      {
        "name": "resolution",
        "description": "Resamples the data cube to the target resolution, which can be specified either as separate values for x and y or as a single value for both axes. Specified in the units of the target projection. Doesn't change the resolution by default (`0`).",
        "schema": [
          {
            "description": "A single number used as resolution for both x and y.",
            "type": "number",
            "minimum": 0
          },
          {
            "description": "A two-element array to specify separate resolutions for x (first element) and y (second element).",
            "type": "array",
            "minItems": 2,
            "maxItems": 2,
            "items": {
              "type": "number",
              "minimum": 0
            }
          }
        ],
        "default": 0,
        "optional": true
      },
      {
        "name": "projection",
        "description": "Warps the data cube to the target projection, specified as as [EPSG code](http://www.epsg-registry.org/), [WKT2 (ISO 19162) string](http://docs.opengeospatial.org/is/18-010r7/18-010r7.html), [PROJ definition (deprecated)](https://proj.org/usage/quickstart.html). By default (`null`), the projection is not changed.",
        "schema": [
          {
            "title": "EPSG Code",
            "type": "integer",
            "subtype": "epsg-code",
            "minimum": 1000,
            "examples": [
              3857
            ]
          },
          {
            "title": "WKT2",
            "type": "string",
            "subtype": "wkt2-definition"
          },
          {
            "title": "PROJ definition",
            "type": "string",
            "subtype": "proj-definition",
            "deprecated": true
          },
          {
            "title": "Don't change projection",
            "type": "null"
          }
        ],
        "default": null,
        "optional": true
      },
      {
        "name": "method",
        "description": "Resampling method. Methods are inspired by GDAL, see [gdalwarp](https://www.gdal.org/gdalwarp.html) for more information.",
        "schema": {
          "type": "string",
          "enum": [
            "near",
            "bilinear",
            "cubic",
            "cubicspline",
            "lanczos",
            "average",
            "mode",
            "max",
            "min",
            "med",
            "q1",
            "q3"
          ]
        },
        "default": "near",
        "optional": true
      },
      {
        "name": "align",
        "description": "Specifies to which corner of the spatial extent the new resampled data is aligned to.",
        "schema": {
          "type": "string",
          "enum": [
            "lower-left",
            "upper-left",
            "lower-right",
            "upper-right"
          ]
        },
        "default": "upper-left",
        "optional": true
      }
    ],
    "returns": {
      "description": "A raster data cube with values warped onto the new projection.",
      "schema": {
        "type": "object",
        "subtype": "raster-cube"
      }
    },
    "links": [
      {
        "rel": "about",
        "href": "https://proj.org/usage/projections.html",
        "title": "PROJ parameters for cartographic projections"
      },
      {
        "rel": "about",
        "href": "http://www.epsg-registry.org",
        "title": "Official EPSG code registry"
      },
      {
        "rel": "about",
        "href": "http://www.epsg.io",
        "title": "Unofficial EPSG code database"
      }
    ]
  },
  {
    "id": "round",
    "summary": "Round to a specified precision",
    "description": "Rounds a real number `x` to specified precision `p`.\n\nIf the fractional part of `x` is halfway between two integers, one of which is even and the other odd, then the even number is returned.\nThis behaviour follows [IEEE Standard 754](https://ieeexplore.ieee.org/document/8766229). This kind of rounding is also called \"rounding to nearest\" or \"banker's rounding\". It minimizes rounding errors that result from consistently rounding a midpoint value in a single direction.\n\nThe no-data value `null` is passed through and therefore gets propagated.",
    "categories": [
      "math > rounding"
    ],
    "parameters": [
      {
        "name": "x",
        "description": "A number to round.",
        "schema": {
          "type": [
            "number",
            "null"
          ]
        }
      },
      {
        "name": "p",
        "description": "A positive number specifies the number of digits after the decimal point to round to. A negative number means rounding to a power of ten, so for example *-2* rounds to the nearest hundred. Defaults to *0*.",
        "schema": {
          "type": "integer"
        },
        "default": 0,
        "optional": true
      }
    ],
    "returns": {
      "description": "The rounded number.",
      "schema": {
        "type": [
          "number",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "x": 0
        },
        "returns": 0
      },
      {
        "arguments": {
          "x": 3.56,
          "p": 1
        },
        "returns": 3.6
      },
      {
        "arguments": {
          "x": -0.4444444,
          "p": 2
        },
        "returns": -0.44
      },
      {
        "arguments": {
          "x": -2.5
        },
        "returns": -2
      },
      {
        "arguments": {
          "x": -3.5
        },
        "returns": -4
      },
      {
        "arguments": {
          "x": 1234.5,
          "p": -2
        },
        "returns": 1200
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "http://mathworld.wolfram.com/AbsoluteValue.html",
        "title": "Absolute value explained by Wolfram MathWorld"
      },
      {
        "rel": "about",
        "href": "https://ieeexplore.ieee.org/document/8766229",
        "title": "IEEE Standard 754-2019 for Floating-Point Arithmetic"
      }
    ]
  },
  {
    "id": "run_udf_externally",
    "summary": "Run an externally hosted UDF container",
    "description": "Runs a compatible UDF container that is either externally hosted by a service provider or running on a local machine of the user. The UDF container must follow the [openEO UDF specification](https://open-eo.github.io/openeo-udf/).\n\nThe referenced UDF service can be executed in several processes such as ``aggregate_spatial()``, ``apply()``, ``apply_dimension()`` and ``reduce_dimension()``. In this case an array is passed instead of a raster data cube. The user must ensure that the data is properly passed as an array so that the UDF can make sense of it.",
    "categories": [
      "import",
      "udf"
    ],
    "experimental": true,
    "parameters": [
      {
        "name": "data",
        "description": "The data to be passed to the UDF as array or raster data cube.",
        "schema": [
          {
            "title": "Raster data cube",
            "type": "object",
            "subtype": "raster-cube"
          },
          {
            "title": "Array",
            "type": "array",
            "minItems": 1,
            "items": {
              "description": "Any data type."
            }
          },
          {
            "title": "Single Value",
            "description": "A single value of any data type."
          }
        ]
      },
      {
        "name": "url",
        "description": "URL to a remote UDF service.",
        "schema": {
          "type": "string",
          "format": "uri",
          "subtype": "uri"
        }
      },
      {
        "name": "context",
        "description": "Additional data such as configuration options that should be passed to the UDF.",
        "schema": {
          "type": "object"
        },
        "default": {},
        "optional": true
      }
    ],
    "returns": {
      "description": "The data processed by the UDF service. Returns a raster data cube if a raster data cube was passed for `data`. If an array was passed for `data`, the returned value is defined by the context and is exactly what the UDF returned.",
      "schema": [
        {
          "title": "Raster data cube",
          "type": "object",
          "subtype": "raster-cube"
        },
        {
          "title": "Any",
          "description": "Any data type."
        }
      ]
    },
    "links": [
      {
        "rel": "about",
        "href": "https://open-eo.github.io/openeo-udf/",
        "title": "openEO UDF specification"
      },
      {
        "rel": "about",
        "href": "https://github.com/Open-EO/openeo-udf",
        "title": "openEO UDF repository"
      }
    ]
  },
  {
    "id": "run_udf",
    "summary": "Run an UDF",
    "description": "Runs an UDF in one of the supported runtime environments.\n\nThe process can either:\n\n1. load and run a locally stored UDF from a file in the workspace of the authenticated user. The path to the UDF file must be relative to the root directory of the user's workspace.\n2. fetch and run a remotely stored and published UDF by absolute URI, for example from [openEO Hub](https://hub.openeo.org)).\n3. run the source code specified inline as string.\n\nThe loaded UDF can be executed in several processes such as ``aggregate_spatial()``, ``apply()``, ``apply_dimension()`` and ``reduce_dimension()``. In this case an array is passed instead of a raster data cube. The user must ensure that the data is properly passed as an array so that the UDF can make sense of it.",
    "categories": [
      "import",
      "udf"
    ],
    "parameters": [
      {
        "name": "data",
        "description": "The data to be passed to the UDF as array or raster data cube.",
        "schema": [
          {
            "title": "Raster data cube",
            "type": "object",
            "subtype": "raster-cube"
          },
          {
            "title": "Array",
            "type": "array",
            "minItems": 1,
            "items": {
              "description": "Any data type."
            }
          },
          {
            "title": "Single Value",
            "description": "A single value of any data type."
          }
        ]
      },
      {
        "name": "udf",
        "description": "Either source code, an absolute URL or a path to an UDF script.",
        "schema": [
          {
            "description": "URI to an UDF",
            "type": "string",
            "format": "uri",
            "subtype": "uri"
          },
          {
            "description": "Path to an UDF uploaded to the server.",
            "type": "string",
            "subtype": "file-path"
          },
          {
            "description": "Source code as string",
            "type": "string",
            "subtype": "udf-code"
          }
        ]
      },
      {
        "name": "runtime",
        "description": "An UDF runtime identifier available at the back-end.",
        "schema": {
          "type": "string",
          "subtype": "udf-runtime"
        }
      },
      {
        "name": "version",
        "description": "An UDF runtime version. If set to `null`, the default runtime version specified for each runtime is used.",
        "schema": [
          {
            "type": "string",
            "subtype": "udf-runtime-version"
          },
          {
            "title": "Default runtime version",
            "type": "null"
          }
        ],
        "default": null,
        "optional": true
      },
      {
        "name": "context",
        "description": "Additional data such as configuration options that should be passed to the UDF.",
        "schema": {
          "type": "object"
        },
        "default": {},
        "optional": true
      }
    ],
    "exceptions": {
      "InvalidVersion": {
        "message": "The specified UDF runtime version is not supported."
      }
    },
    "returns": {
      "description": "The data processed by the UDF. Returns a raster data cube if a raster data cube was passed for `data`. If an array was passed for `data`, the returned value is defined by the context and is exactly what the UDF returned.",
      "schema": [
        {
          "title": "Raster data cube",
          "type": "object",
          "subtype": "raster-cube"
        },
        {
          "title": "Any",
          "description": "Any data type."
        }
      ]
    }
  },
  {
    "id": "save_result",
    "summary": "Save processed data to storage",
    "description": "Saves processed data to the local user workspace / data store of the authenticated user. This process aims to be compatible to GDAL/OGR formats and options. STAC-compatible metadata should be stored with the processed data.\n\nCalling this process may be rejected by back-ends in the context of secondary web services.",
    "categories": [
      "cubes",
      "export"
    ],
    "parameters": [
      {
        "name": "data",
        "description": "The data to save.",
        "schema": [
          {
            "type": "object",
            "subtype": "raster-cube"
          },
          {
            "type": "object",
            "subtype": "vector-cube"
          }
        ]
      },
      {
        "name": "format",
        "description": "The file format to save to. It must be one of the values that the server reports as supported output file formats, which usually correspond to the short GDAL/OGR codes. This parameter is *case insensitive*.",
        "schema": {
          "type": "string",
          "subtype": "output-format"
        }
      },
      {
        "name": "options",
        "description": "The file format options to be used to create the file(s). Must correspond to the options that the server reports as supported options for the chosen `format`. The option names and valid values usually correspond to the GDAL/OGR format options.",
        "schema": {
          "type": "object",
          "subtype": "output-format-options"
        },
        "default": {},
        "optional": true
      }
    ],
    "returns": {
      "description": "`false` if saving failed, `true` otherwise.",
      "schema": {
        "type": "boolean"
      }
    },
    "links": [
      {
        "rel": "about",
        "href": "https://www.gdal.org/formats_list.html",
        "title": "GDAL Raster Formats"
      },
      {
        "rel": "about",
        "href": "https://www.gdal.org/ogr_formats.html",
        "title": "OGR Vector Formats"
      }
    ]
  },
  {
    "id": "sd",
    "summary": "Standard deviation",
    "description": "Computes the sample standard deviation, which quantifies the amount of variation of an array of numbers. It is defined to be the square root of the corresponding variance (see ``variance()``).\n\nA low standard deviation indicates that the values tend to be close to the expected value, while a high standard deviation indicates that the values are spread out over a wider range.",
    "categories": [
      "math",
      "reducer"
    ],
    "parameters": [
      {
        "name": "data",
        "description": "An array of numbers. An empty array resolves always with `null`.",
        "schema": {
          "type": "array",
          "items": {
            "type": [
              "number",
              "null"
            ]
          }
        }
      },
      {
        "name": "ignore_nodata",
        "description": "Indicates whether no-data values are ignored or not. Ignores them by default. Setting this flag to `false` considers no-data values so that `null` is returned if any value is such a value.",
        "schema": {
          "type": "boolean"
        },
        "default": true,
        "optional": true
      }
    ],
    "returns": {
      "description": "The computed sample standard deviation.",
      "schema": {
        "type": [
          "number",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "data": [
            -1,
            1,
            3,
            null
          ]
        },
        "returns": 2
      },
      {
        "arguments": {
          "data": [
            -1,
            1,
            3,
            null
          ],
          "ignore_nodata": false
        },
        "returns": null
      },
      {
        "description": "The input array is empty: return `null`.",
        "arguments": {
          "data": []
        },
        "returns": null
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "http://mathworld.wolfram.com/StandardDeviation.html",
        "title": "Standard deviation explained by Wolfram MathWorld"
      }
    ],
    "process_graph": {
      "variance": {
        "process_id": "variance",
        "arguments": {
          "data": {
            "from_parameter": "data"
          },
          "ignore_nodata": {
            "from_parameter": "ignore_nodata"
          }
        }
      },
      "power": {
        "process_id": "power",
        "arguments": {
          "base": {
            "from_node": "variance"
          },
          "p": 0.5
        },
        "result": true
      }
    }
  },
  {
    "id": "sgn",
    "summary": "Signum",
    "description": "The signum (also known as *sign*) of `x` is defined as:\n\n* *1* if *x > 0*\n* *0* if *x = 0*\n* *-1* if *x < 0*\n\nThe no-data value `null` is passed through and therefore gets propagated.",
    "categories": [
      "math"
    ],
    "parameters": [
      {
        "name": "x",
        "description": "A number.",
        "schema": {
          "type": [
            "number",
            "null"
          ]
        }
      }
    ],
    "returns": {
      "description": "The computed signum value of `x`.",
      "schema": {
        "type": [
          "number",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "x": -2
        },
        "returns": -1
      },
      {
        "arguments": {
          "x": 3.5
        },
        "returns": 1
      },
      {
        "arguments": {
          "x": 0
        },
        "returns": 0
      },
      {
        "arguments": {
          "x": null
        },
        "returns": null
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "http://mathworld.wolfram.com/Sign.html",
        "title": "Sign explained by Wolfram MathWorld"
      }
    ],
    "process_graph": {
      "gt0": {
        "process_id": "gt",
        "arguments": {
          "x": {
            "from_parameter": "x"
          },
          "y": 0
        }
      },
      "lt0": {
        "process_id": "lt",
        "arguments": {
          "x": {
            "from_parameter": "x"
          },
          "y": 0
        }
      },
      "if_gt0": {
        "process_id": "if",
        "arguments": {
          "value": {
            "from_node": "gt0"
          },
          "accept": 1,
          "reject": {
            "from_parameter": "x"
          }
        }
      },
      "if_lt0": {
        "process_id": "if",
        "arguments": {
          "value": {
            "from_node": "lt0"
          },
          "accept": -1,
          "reject": {
            "from_node": "if_gt0"
          }
        },
        "result": true
      }
    }
  },
  {
    "id": "sin",
    "summary": "Sine",
    "description": "Computes the sine of `x`.\n\nWorks on radians only.\nThe no-data value `null` is passed through and therefore gets propagated.",
    "categories": [
      "math > trigonometric"
    ],
    "parameters": [
      {
        "name": "x",
        "description": "An angle in radians.",
        "schema": {
          "type": [
            "number",
            "null"
          ]
        }
      }
    ],
    "returns": {
      "description": "The computed sine of `x`.",
      "schema": {
        "type": [
          "number",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "x": 0
        },
        "returns": 0
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "http://mathworld.wolfram.com/Sine.html",
        "title": "Sine explained by Wolfram MathWorld"
      }
    ]
  },
  {
    "id": "sinh",
    "summary": "Hyperbolic sine",
    "description": "Computes the hyperbolic sine of `x`.\n\nWorks on radians only.\nThe no-data value `null` is passed through and therefore gets propagated.",
    "categories": [
      "math > trigonometric"
    ],
    "parameters": [
      {
        "name": "x",
        "description": "An angle in radians.",
        "schema": {
          "type": [
            "number",
            "null"
          ]
        }
      }
    ],
    "returns": {
      "description": "The computed hyperbolic sine of `x`.",
      "schema": {
        "type": [
          "number",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "x": 0
        },
        "returns": 0
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "http://mathworld.wolfram.com/HyperbolicSine.html",
        "title": "Hyperbolic sine explained by Wolfram MathWorld"
      }
    ]
  },
  {
    "id": "sort",
    "summary": "Sort data",
    "description": "Sorts an array into ascending (default) or descending order.\n\n**Remarks:**\n\n* Ties will be left in their original ordering.\n* Temporal strings can *not* be compared based on their string representation due to the time zone / time-offset representations.",
    "categories": [
      "arrays",
      "sorting"
    ],
    "parameters": [
      {
        "name": "data",
        "description": "An array with data to sort.",
        "schema": {
          "type": "array",
          "items": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "null"
              },
              {
                "type": "string",
                "format": "date-time",
                "subtype": "date-time"
              },
              {
                "type": "string",
                "format": "date",
                "subtype": "date"
              },
              {
                "type": "string",
                "format": "time",
                "subtype": "time"
              }
            ]
          }
        }
      },
      {
        "name": "asc",
        "description": "The default sort order is ascending, with smallest values first. To sort in reverse (descending) order, set this parameter to `false`.",
        "schema": {
          "type": "boolean"
        },
        "default": true,
        "optional": true
      },
      {
        "name": "nodata",
        "description": "Controls the handling of no-data values (`null`). By default they are removed. If `true`, missing values in the data are put last; if `false`, they are put first.",
        "schema": {
          "type": [
            "boolean",
            "null"
          ]
        },
        "default": null,
        "optional": true
      }
    ],
    "returns": {
      "description": "The sorted array.",
      "schema": {
        "type": "array",
        "items": {
          "anyOf": [
            {
              "type": "number"
            },
            {
              "type": "null"
            },
            {
              "type": "string",
              "format": "date-time",
              "subtype": "date-time"
            },
            {
              "type": "string",
              "format": "date",
              "subtype": "date"
            },
            {
              "type": "string",
              "format": "time",
              "subtype": "time"
            }
          ]
        }
      }
    },
    "examples": [
      {
        "arguments": {
          "data": [
            6,
            -1,
            2,
            null,
            7,
            4,
            null,
            8,
            3,
            9,
            9
          ]
        },
        "returns": [
          -1,
          2,
          3,
          4,
          6,
          7,
          8,
          9,
          9
        ]
      },
      {
        "arguments": {
          "data": [
            6,
            -1,
            2,
            null,
            7,
            4,
            null,
            8,
            3,
            9,
            9
          ],
          "asc": false,
          "nodata": true
        },
        "returns": [
          9,
          9,
          8,
          7,
          6,
          4,
          3,
          2,
          -1,
          null,
          null
        ]
      }
    ],
    "process_graph": {
      "order": {
        "process_id": "order",
        "arguments": {
          "data": {
            "from_parameter": "data"
          },
          "asc": {
            "from_parameter": "asc"
          },
          "nodata": {
            "from_parameter": "nodata"
          }
        }
      },
      "rearrange": {
        "process_id": "rearrange",
        "arguments": {
          "data": {
            "from_parameter": "data"
          },
          "order": {
            "from_node": "order"
          }
        },
        "result": true
      }
    }
  },
  {
    "id": "sqrt",
    "summary": "Square root",
    "description": "Computes the square root of a real number `x`, which is equal to calculating `x` to the power of *0.5*.\n\nA square root of x is a number a such that *a^2^ = x*. Therefore, the square root is the inverse function of a to the power of 2, but only for *a >= 0*.\n\nThe no-data value `null` is passed through and therefore gets propagated.",
    "categories": [
      "math",
      "math > exponential & logarithmic"
    ],
    "parameters": [
      {
        "name": "x",
        "description": "A number.",
        "schema": {
          "type": [
            "number",
            "null"
          ]
        }
      }
    ],
    "returns": {
      "description": "The computed square root.",
      "schema": {
        "type": [
          "number",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "x": 0
        },
        "returns": 0
      },
      {
        "arguments": {
          "x": 1
        },
        "returns": 1
      },
      {
        "arguments": {
          "x": 9
        },
        "returns": 3
      },
      {
        "arguments": {
          "x": null
        },
        "returns": null
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "http://mathworld.wolfram.com/SquareRoot.html",
        "title": "Square root explained by Wolfram MathWorld"
      }
    ],
    "process_graph": {
      "power": {
        "process_id": "power",
        "arguments": {
          "base": {
            "from_parameter": "x"
          },
          "p": 0.5
        },
        "result": true
      }
    }
  },
  {
    "id": "subtract",
    "summary": "Subtraction of two numbers",
    "description": "Subtracts argument `y` from the argument `x` (*x - y*) and returns the computed result.\n\nNo-data values are taken into account so that `null` is returned if any element is such a value.\n\nThe computations follow [IEEE Standard 754](https://ieeexplore.ieee.org/document/8766229) whenever the processing environment supports it.",
    "categories": [
      "math"
    ],
    "parameters": [
      {
        "name": "x",
        "description": "The minuend.",
        "schema": {
          "type": [
            "number",
            "null"
          ]
        }
      },
      {
        "name": "y",
        "description": "The subtrahend.",
        "schema": {
          "type": [
            "number",
            "null"
          ]
        }
      }
    ],
    "returns": {
      "description": "The computed result.",
      "schema": {
        "type": [
          "number",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "x": 5,
          "y": 2.5
        },
        "returns": 2.5
      },
      {
        "arguments": {
          "x": -2,
          "y": 4
        },
        "returns": -6
      },
      {
        "arguments": {
          "x": 1,
          "y": null
        },
        "returns": null
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "http://mathworld.wolfram.com/Subtraction.html",
        "title": "Subtraction explained by Wolfram MathWorld"
      },
      {
        "rel": "about",
        "href": "https://ieeexplore.ieee.org/document/8766229",
        "title": "IEEE Standard 754-2019 for Floating-Point Arithmetic"
      }
    ]
  },
  {
    "id": "sum",
    "summary": "Compute the sum by adding up numbers",
    "description": "Sums up all elements in a sequential array of numbers and returns the computed sum.\n\nBy default no-data values are ignored. Setting `ignore_nodata` to `false` considers no-data values so that `null` is returned if any element is such a value.\n\nThe computations follow [IEEE Standard 754](https://ieeexplore.ieee.org/document/8766229) whenever the processing environment supports it.",
    "categories": [
      "math",
      "reducer"
    ],
    "parameters": [
      {
        "name": "data",
        "description": "An array of numbers.",
        "schema": {
          "type": "array",
          "items": {
            "type": [
              "number",
              "null"
            ]
          }
        }
      },
      {
        "name": "ignore_nodata",
        "description": "Indicates whether no-data values are ignored or not. Ignores them by default. Setting this flag to `false` considers no-data values so that `null` is returned if any value is such a value.",
        "schema": {
          "type": "boolean"
        },
        "default": true,
        "optional": true
      }
    ],
    "returns": {
      "description": "The computed sum of the sequence of numbers.",
      "schema": {
        "type": [
          "number",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "data": [
            5,
            1
          ]
        },
        "returns": 6
      },
      {
        "arguments": {
          "data": [
            -2,
            4,
            2.5
          ]
        },
        "returns": 4.5
      },
      {
        "arguments": {
          "data": [
            1,
            null
          ],
          "ignore_nodata": false
        },
        "returns": null
      },
      {
        "arguments": {
          "data": [
            100
          ]
        },
        "returns": 100
      },
      {
        "arguments": {
          "data": [
            null
          ],
          "ignore_nodata": false
        },
        "returns": null
      },
      {
        "arguments": {
          "data": []
        },
        "returns": null
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "http://mathworld.wolfram.com/Sum.html",
        "title": "Sum explained by Wolfram MathWorld"
      },
      {
        "rel": "about",
        "href": "https://ieeexplore.ieee.org/document/8766229",
        "title": "IEEE Standard 754-2019 for Floating-Point Arithmetic"
      }
    ]
  },
  {
    "id": "tan",
    "summary": "Tangent",
    "description": "Computes the tangent of `x`. The tangent is defined to be the sine of x divided by the cosine of x.\n\nWorks on radians only.\nThe no-data value `null` is passed through and therefore gets propagated.",
    "categories": [
      "math > trigonometric"
    ],
    "parameters": [
      {
        "name": "x",
        "description": "An angle in radians.",
        "schema": {
          "type": [
            "number",
            "null"
          ]
        }
      }
    ],
    "returns": {
      "description": "The computed tangent of `x`.",
      "schema": {
        "type": [
          "number",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "x": 0
        },
        "returns": 0
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "http://mathworld.wolfram.com/Tangent.html",
        "title": "Tangent explained by Wolfram MathWorld"
      }
    ]
  },
  {
    "id": "tanh",
    "summary": "Hyperbolic tangent",
    "description": "Computes the hyperbolic tangent of `x`. The tangent is defined to be the hyperbolic sine of x divided by the hyperbolic cosine of x.\n\nWorks on radians only.\nThe no-data value `null` is passed through and therefore gets propagated.",
    "categories": [
      "math > trigonometric"
    ],
    "parameters": [
      {
        "name": "x",
        "description": "An angle in radians.",
        "schema": {
          "type": [
            "number",
            "null"
          ]
        }
      }
    ],
    "returns": {
      "description": "The computed hyperbolic tangent of `x`.",
      "schema": {
        "type": [
          "number",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "x": 0
        },
        "returns": 0
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "http://mathworld.wolfram.com/HyperbolicTangent.html",
        "title": "Hyperbolic tangent explained by Wolfram MathWorld"
      }
    ]
  },
  {
    "id": "text_begins",
    "summary": "Text begins with another text",
    "description": "Checks whether the text (also known as *string*) specified for `data` contains the text specified for `pattern` at the beginning. Both are expected to be encoded in UTF-8 by default. The no-data value `null` is passed through and therefore gets propagated.",
    "categories": [
      "texts",
      "comparison"
    ],
    "parameters": [
      {
        "name": "data",
        "description": "Text in which to find something at the beginning.",
        "schema": {
          "type": [
            "string",
            "null"
          ]
        }
      },
      {
        "name": "pattern",
        "description": "Text to find at the beginning of `data`. Regular expressions are not supported.",
        "schema": {
          "type": "string"
        }
      },
      {
        "name": "case_sensitive",
        "description": "Case sensitive comparison can be disabled by setting this parameter to `false`.",
        "schema": {
          "type": "boolean"
        },
        "default": true,
        "optional": true
      }
    ],
    "returns": {
      "description": "`true` if `data` begins with `pattern`, false` otherwise.",
      "schema": {
        "type": [
          "boolean",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "data": "Lorem ipsum dolor sit amet",
          "pattern": "amet"
        },
        "returns": false
      },
      {
        "arguments": {
          "data": "Lorem ipsum dolor sit amet",
          "pattern": "Lorem"
        },
        "returns": true
      },
      {
        "arguments": {
          "data": "Lorem ipsum dolor sit amet",
          "pattern": "lorem"
        },
        "returns": false
      },
      {
        "arguments": {
          "data": "Lorem ipsum dolor sit amet",
          "pattern": "lorem",
          "case_sensitive": false
        },
        "returns": true
      },
      {
        "arguments": {
          "data": "",
          "pattern": "",
          "case_sensitive": false
        },
        "returns": true
      },
      {
        "arguments": {
          "data": null,
          "pattern": "null"
        },
        "returns": null
      }
    ]
  },
  {
    "id": "text_contains",
    "summary": "Text contains another text",
    "description": "Checks whether the text (also known as *string*) specified for `data` contains the text specified for `pattern`. Both are expected to be encoded in UTF-8 by default. The no-data value `null` is passed through and therefore gets propagated.",
    "categories": [
      "texts",
      "comparison"
    ],
    "parameters": [
      {
        "name": "data",
        "description": "Text in which to find something in.",
        "schema": {
          "type": [
            "string",
            "null"
          ]
        }
      },
      {
        "name": "pattern",
        "description": "Text to find in `data`. Regular expressions are not supported.",
        "schema": {
          "type": "string"
        }
      },
      {
        "name": "case_sensitive",
        "description": "Case sensitive comparison can be disabled by setting this parameter to `false`.",
        "schema": {
          "type": "boolean"
        },
        "default": true,
        "optional": true
      }
    ],
    "returns": {
      "description": "`true` if `data` contains the `pattern`, false` otherwise.",
      "schema": {
        "type": [
          "boolean",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "data": "Lorem ipsum dolor sit amet",
          "pattern": "openEO"
        },
        "returns": false
      },
      {
        "arguments": {
          "data": "Lorem ipsum dolor sit amet",
          "pattern": "ipsum dolor"
        },
        "returns": true
      },
      {
        "arguments": {
          "data": "Lorem ipsum dolor sit amet",
          "pattern": "Ipsum Dolor"
        },
        "returns": false
      },
      {
        "arguments": {
          "data": "Lorem ipsum dolor sit amet",
          "pattern": "SIT",
          "case_sensitive": false
        },
        "returns": true
      },
      {
        "arguments": {
          "data": "",
          "pattern": "",
          "case_sensitive": false
        },
        "returns": true
      },
      {
        "arguments": {
          "data": null,
          "pattern": "null"
        },
        "returns": null
      }
    ]
  },
  {
    "id": "text_ends",
    "summary": "Text ends with another text",
    "description": "Checks whether the text (also known as *string*) specified for `data` contains the text specified for `pattern` at the end. Both are expected to be encoded in UTF-8 by default. The no-data value `null` is passed through and therefore gets propagated.",
    "categories": [
      "texts",
      "comparison"
    ],
    "parameters": [
      {
        "name": "data",
        "description": "Text in which to find something at the end.",
        "schema": {
          "type": [
            "string",
            "null"
          ]
        }
      },
      {
        "name": "pattern",
        "description": "Text to find at the end of `data`. Regular expressions are not supported.",
        "schema": {
          "type": "string"
        }
      },
      {
        "name": "case_sensitive",
        "description": "Case sensitive comparison can be disabled by setting this parameter to `false`.",
        "schema": {
          "type": "boolean"
        },
        "default": true,
        "optional": true
      }
    ],
    "returns": {
      "description": "`true` if `data` ends with `pattern`, false` otherwise.",
      "schema": {
        "type": [
          "boolean",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "data": "Lorem ipsum dolor sit amet",
          "pattern": "amet"
        },
        "returns": true
      },
      {
        "arguments": {
          "data": "Lorem ipsum dolor sit amet",
          "pattern": "AMET"
        },
        "returns": false
      },
      {
        "arguments": {
          "data": "Lorem ipsum dolor sit amet",
          "pattern": "Lorem"
        },
        "returns": false
      },
      {
        "arguments": {
          "data": "Lorem ipsum dolor sit amet",
          "pattern": "AMET",
          "case_sensitive": false
        },
        "returns": true
      },
      {
        "arguments": {
          "data": "",
          "pattern": "",
          "case_sensitive": false
        },
        "returns": true
      },
      {
        "arguments": {
          "data": null,
          "pattern": "null"
        },
        "returns": null
      }
    ]
  },
  {
    "id": "text_merge",
    "summary": "Concatenate elements to a string",
    "description": "Merges string representations of a set of elements together to a single string, with the separator between each element.",
    "categories": [
      "texts"
    ],
    "parameters": [
      {
        "name": "data",
        "description": "A set of elements. Numbers, boolean values and null values get converted to their (lower case) string representation. For example: `1` (integer), `-1.5` (number), `true` / `false` (boolean values)",
        "schema": {
          "type": "array",
          "items": {
            "type": [
              "string",
              "number",
              "boolean",
              "null"
            ]
          }
        }
      },
      {
        "name": "separator",
        "description": "A separator to put between each of the individual texts. Defaults to an empty string.",
        "schema": {
          "type": [
            "string",
            "number",
            "boolean",
            "null"
          ]
        },
        "default": "",
        "optional": true
      }
    ],
    "returns": {
      "description": "Returns a string containing a string representation of all the array elements in the same order, with the separator between each element.",
      "schema": {
        "type": "string"
      }
    },
    "examples": [
      {
        "arguments": {
          "data": [
            "Hello",
            "World"
          ],
          "separator": " "
        },
        "returns": "Hello World"
      },
      {
        "arguments": {
          "data": [
            1,
            2,
            3,
            4,
            5,
            6,
            7,
            8,
            9,
            0
          ]
        },
        "returns": "1234567890"
      },
      {
        "arguments": {
          "data": [
            null,
            true,
            false,
            1,
            -1.5,
            ""
          ],
          "separator": "\n"
        },
        "returns": "null\ntrue\nfalse\n1\n-1.5\n"
      },
      {
        "arguments": {
          "data": [
            2,
            0
          ],
          "separator": 1
        },
        "returns": "210"
      },
      {
        "arguments": {
          "data": []
        },
        "returns": ""
      }
    ]
  },
  {
    "id": "trim_cube",
    "summary": "Remove slices with no-data values",
    "description": "Removes slices solely containing no-data values. If the dimension is irregular categorical then slices in the middle can be removed.",
    "categories": [
      "cubes"
    ],
    "parameters": [
      {
        "name": "data",
        "description": "A raster data cube to trim.",
        "schema": {
          "type": "object",
          "subtype": "raster-cube"
        }
      }
    ],
    "returns": {
      "description": "A trimmed raster data cube.",
      "schema": {
        "type": "object",
        "subtype": "raster-cube"
      }
    }
  },
  {
    "id": "variance",
    "summary": "Variance",
    "description": "Computes the sample variance of an array of numbers by calculating the square of the standard deviation (see ``sd()``). It is defined to be the expectation of the squared deviation of a random variable from its expected value. Basically, it measures how far the numbers in the array are spread out from their average value.",
    "categories": [
      "math",
      "reducer"
    ],
    "parameters": [
      {
        "name": "data",
        "description": "An array of numbers. An empty array resolves always with `null`.",
        "schema": {
          "type": "array",
          "items": {
            "type": [
              "number",
              "null"
            ]
          }
        }
      },
      {
        "name": "ignore_nodata",
        "description": "Indicates whether no-data values are ignored or not. Ignores them by default. Setting this flag to `false` considers no-data values so that `null` is returned if any value is such a value.",
        "schema": {
          "type": "boolean"
        },
        "default": true,
        "optional": true
      }
    ],
    "returns": {
      "description": "The computed sample variance.",
      "schema": {
        "type": [
          "number",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "data": [
            -1,
            1,
            3
          ]
        },
        "returns": 4
      },
      {
        "arguments": {
          "data": [
            2,
            3,
            3,
            null,
            4,
            4,
            5
          ]
        },
        "returns": 1.1
      },
      {
        "arguments": {
          "data": [
            -1,
            1,
            null,
            3
          ],
          "ignore_nodata": false
        },
        "returns": null
      },
      {
        "description": "The input array is empty: return `null`.",
        "arguments": {
          "data": []
        },
        "returns": null
      }
    ],
    "links": [
      {
        "rel": "about",
        "href": "http://mathworld.wolfram.com/Variance.html",
        "title": "Variance explained by Wolfram MathWorld"
      }
    ],
    "process_graph": {
      "mean": {
        "process_id": "mean",
        "arguments": {
          "data": {
            "from_parameter": "data"
          }
        }
      },
      "apply": {
        "process_id": "apply",
        "arguments": {
          "data": {
            "from_parameter": "data"
          },
          "process": {
            "process-graph": {
              "subtract": {
                "process_id": "subtract",
                "arguments": {
                  "x": {
                    "from_parameter": "x"
                  },
                  "y": {
                    "from_parameter": "context"
                  }
                }
              },
              "power": {
                "process_id": "power",
                "arguments": {
                  "base": {
                    "from_node": "subtract"
                  },
                  "p": 2
                },
                "result": true
              }
            }
          },
          "context": {
            "from_node": "mean"
          }
        }
      },
      "mean2": {
        "process_id": "mean",
        "arguments": {
          "data": {
            "from_node": "apply"
          },
          "ignore_nodata": {
            "from_parameter": "ignore_nodata"
          }
        },
        "result": true
      }
    }
  },
  {
    "id": "xor",
    "summary": "Logical XOR (exclusive or)",
    "description": "Checks if **exactly one** of the values is true. If a component is `null`, the result will be `null` if the outcome is ambiguous.\n\n**Truth table:**\n\n```\na \\ b || null | false | true\n----- || ---- | ----- | -----\nnull  || null | null  | null\nfalse || null | false | true\ntrue  || null | true  | false\n```",
    "categories": [
      "logic"
    ],
    "parameters": [
      {
        "name": "x",
        "description": "A boolean value.",
        "schema": {
          "type": [
            "boolean",
            "null"
          ]
        }
      },
      {
        "name": "y",
        "description": "A boolean value.",
        "schema": {
          "type": [
            "boolean",
            "null"
          ]
        }
      }
    ],
    "returns": {
      "description": "Boolean result of the logical XOR.",
      "schema": {
        "type": [
          "boolean",
          "null"
        ]
      }
    },
    "examples": [
      {
        "arguments": {
          "x": true,
          "y": true
        },
        "returns": false
      },
      {
        "arguments": {
          "x": false,
          "y": false
        },
        "returns": false
      },
      {
        "arguments": {
          "x": true,
          "y": false
        },
        "returns": true
      },
      {
        "arguments": {
          "x": true,
          "y": null
        },
        "returns": null
      },
      {
        "arguments": {
          "x": false,
          "y": null
        },
        "returns": null
      }
    ],
    "process_graph": {
      "not_x": {
        "process_id": "not",
        "arguments": {
          "x": {
            "from_parameter": "x"
          }
        }
      },
      "not_y": {
        "process_id": "not",
        "arguments": {
          "x": {
            "from_parameter": "y"
          }
        }
      },
      "and1": {
        "process_id": "and",
        "arguments": {
          "x": {
            "from_node": "not_x"
          },
          "y": {
            "from_parameter": "y"
          }
        }
      },
      "and2": {
        "process_id": "and",
        "arguments": {
          "x": {
            "from_parameter": "x"
          },
          "y": {
            "from_node": "not_y"
          }
        }
      },
      "or": {
        "process_id": "or",
        "arguments": {
          "x": {
            "from_node": "and1"
          },
          "y": {
            "from_node": "and2"
          }
        },
        "result": true
      }
    }
  }
]